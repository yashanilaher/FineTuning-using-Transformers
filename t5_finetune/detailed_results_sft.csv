rouge1,rouge2,rougeL,bleu,codebleu,syntax_correct,generation_time,reference,generated,model
0.4,0.27397260273972607,0.4,0.4068825656011934,0.4068825656011934,0,3.0748605728149414,"def inherit_type(self, type_cls: Type[TInherit]) \
            -> Union[TInherit, 'Publisher']:
        """""" enables the usage of method and attribute overloading for this
        publisher.
        """"""
        self._inherited_type = type_cls
        return self","def _enable_method_and_attribute_overloading(self): """""" enables the usage of method and attribute overloading for this publisher. """""" if self._method_and_attribute_overloading: self._method_and_attribute_overloading = self._method_and_attribute_overloading if self._method_and_attribute_overloading: self._method_and_attribute_overloading = self",SFT
0.38235294117647056,0.1515151515151515,0.38235294117647056,0.24749596708462032,0.24749596708462032,0,2.2738683223724365,"def auto_mounter(original):
    """"""Decorator for automatically mounting, if needed.""""""
    def mounter(*args):
        """"""If not mounted, mount.""""""
        self = args[0]
        if not self.is_mounted():
            self.mount()
        return original(*args)
    return mounter","def decorator(self): """"""Decorator for automatically mounting, if needed."""""" if self._decorator is None: self._decorator = self._decorator if self._decorator is None: self._decorator = self._decorator if self._decorator is None: self._decorator = self._decorator",SFT
0.4033613445378151,0.358974358974359,0.4033613445378151,0.3427964056694564,0.3427964056694564,0,3.094439744949341,"def applyTransform(self):
        """"""
        Convenience utility to apply the specified transform to the specified pose.
          This properly transforms all pose components, including velocity and angular velocity
        """"""

        fn = self.function_table.applyTransform
        pOutputPose = TrackedDevicePose_t()
        pTrackedDevicePose = TrackedDevicePose_t()
        pTransform = HmdMatrix34_t()
        fn(byref(pOutputPose), byref(pTrackedDevicePose), byref(pTransform))
        return pOutputPose, pTrackedDevicePose, pTransform","def apply_transform(self, pose): """""" Convenience utility to apply the specified transform to the specified pose. This properly transforms all pose components, including velocity and angular velocity """""" if pose is None: raise ValueError(""Transform is not a pose"") if pose is None: raise ValueError(""Transform is not a pose"") if pose is None: raise ValueError(""Transform is not a pose"") if pose is None: raise ValueError(""Transform is not",SFT
0.1963824289405685,0.06753246753246754,0.165374677002584,0.0008916282659680287,0.0008916282659680287,0,3.015538454055786,"def next_window(self, widget, data=None):
        """"""
        Function opens the run Window who executes the
        assistant project creation
        """"""
        # check whether deps-only is selected
        deps_only = ('deps_only' in self.args and self.args['deps_only']['checkbox'].get_active())

        # preserve argument value if it is needed to be preserved
        for arg_dict in [x for x in self.args.values() if 'preserved' in x['arg'].kwargs]:
            preserve_key = arg_dict['arg'].kwargs['preserved']
            # preserve entry text (string value)
            if 'entry' in arg_dict:
                if self.arg_is_selected(arg_dict):
                    config_manager.set_config_value(preserve_key, arg_dict['entry'].get_text())
            # preserve if checkbox is ticked (boolean value)
            else:
                config_manager.set_config_value(preserve_key, self.arg_is_selected(arg_dict))

        # save configuration into file
        config_manager.save_configuration_file()
        # get project directory and name
        project_dir = self.dir_name.get_text()
        full_name = self.get_full_dir_name()

        # check whether project directory and name is properly set
        if not deps_only and self.current_main_assistant.name == 'crt':
            if project_dir == """":
                return self.gui_helper.execute_dialog(""Specify directory for project"")
            else:
                # check whether directory is existing
                if not os.path.isdir(project_dir):
                    response = self.gui_helper.create_question_dialog(
                        ""Directory {0} does not exists"".format(project_dir),
                        ""Do you want to create them?""
                    )
                    if response == Gtk.ResponseType.NO:
                        # User do not want to create a directory
                        return
                    else:
                        # Create directory
                        try:
                            os.makedirs(project_dir)
                        except OSError as os_err:
                            return self.gui_helper.execute_dialog(""{0}"".format(os_err))
                elif os.path.isdir(full_name):
                    return self.check_for_directory(full_name)

        if not self._build_flags():
            return

        if not deps_only and self.current_main_assistant.name == 'crt':
            self.kwargs['name'] = full_name
        self.kwargs['__ui__'] = 'gui_gtk+'

        self.data['kwargs'] = self.kwargs
        self.data['top_assistant'] = self.top_assistant
        self.data['current_main_assistant'] = self.current_main_assistant
        self.parent.run_window.open_window(widget, self.data)
        self.path_window.hide()","def _open_run_window(self): """""" Function opens the run Window who executes the assistant project creation """""" if self._run_window is None: self._run_window = self._run_window if self._run_window is None: self._run_window = self._run_window else: self._run_window = self._run_window if self._run_window is None: self._run_window = self._run",SFT
0.6488294314381271,0.632996632996633,0.6488294314381271,0.3454719333877064,0.3454719333877064,0,3.495511770248413,"def remove_member_roles(self, guild_id: int, member_id: int, roles: List[int]):
        """"""Add roles to a member

        This method takes a list of **role ids** that you want to strip from the user,
        subtracting from whatever roles they may already have. This method will fetch
        the user's current roles, and add to that list the roles passed in. This method
        will only remove roles from the user that they have at the time of execution,
        so you don't need to check that the user has the roles you're trying to remove
        from them (as long as those roles are valid roles for this guild).

        This method differs from ``set_member_roles`` in that this method REMOVES roles
        from the user's current role list. ``set_member_roles`` is used by this method.

        Args:
            guild_id: snowflake id of the guild
            member_id: snowflake id of the member
            roles: list of snowflake ids of roles to remove
        """"""
        current_roles = [role for role in self.get_guild_member_by_id(guild_id, member_id)['roles']]
        new_list = [role for role in current_roles if role not in roles]
        self.set_member_roles(guild_id, member_id, new_list)","def add_roles(self): """"""Add roles to a member This method takes a list of **role ids** that you want to strip from the user, subtracting from whatever roles they may already have. This method will fetch the user's current roles, and add to that list the roles passed in. This method will only remove roles from the user that they have at the time of execution, so you don't need to check that the user has the roles you're trying to remove from them (as long as those roles are valid roles for this",SFT
0.14500000000000002,0.08040201005025126,0.135,1.7204219952109643e-05,1.7204219952109643e-05,0,1.6505012512207031,"def _ingest_dict(self, input_dict, schema_dict, path_to_root):

        '''
            a helper method for ingesting keys, value pairs in a dictionary

        :return: valid_dict
        '''

        valid_dict = {}

    # construct path to root for rules
        rules_path_to_root = re.sub('\[\d+\]', '[0]', path_to_root)

    # iterate over keys in schema dict
        for key, value in schema_dict.items():
            key_path = path_to_root
            if not key_path == '.':
                key_path += '.'
            key_path += key
            rules_key_path = re.sub('\[\d+\]', '[0]', key_path)
            value_match = False
            if key in input_dict.keys():
                value_index = self._datatype_classes.index(value.__class__)
                value_type = self._datatype_names[value_index]
                try:
                    v_index = self._datatype_classes.index(input_dict[key].__class__)
                    v_type = self._datatype_names[v_index]
                    if v_type == value_type:
                        value_match = True
                except:
                    value_match = False
            if value_match:
                if value_type == 'null':
                    valid_dict[key] = input_dict[key]
                elif value_type == 'boolean':
                    valid_dict[key] = self._ingest_boolean(input_dict[key], key_path)
                elif value_type == 'number':
                    valid_dict[key] = self._ingest_number(input_dict[key], key_path)
                elif value_type == 'string':
                    valid_dict[key] = self._ingest_string(input_dict[key], key_path)
                elif value_type == 'map':
                    valid_dict[key] = self._ingest_dict(input_dict[key], schema_dict[key], key_path)
                elif value_type == 'list':
                    valid_dict[key] = self._ingest_list(input_dict[key], schema_dict[key], key_path)
            else:
                value_type = self.keyMap[rules_key_path]['value_datatype']
                if 'default_value' in self.keyMap[rules_key_path]:
                    valid_dict[key] = self.keyMap[rules_key_path]['default_value']
                elif value_type == 'null':
                    valid_dict[key] = None
                elif value_type == 'boolean':
                    valid_dict[key] = False
                elif value_type == 'number':
                    valid_dict[key] = 0.0
                    if 'integer_data' in self.keyMap[rules_key_path].keys():
                        if self.keyMap[rules_key_path]['integer_data']:
                            valid_dict[key] = 0
                elif value_type == 'string':
                    valid_dict[key] = ''
                elif value_type == 'list':
                    valid_dict[key] = []
                elif value_type == 'map':
                    valid_dict[key] = self._ingest_dict({}, schema_dict[key], key_path)

    # add extra fields if set to True
        if self.keyMap[rules_path_to_root]['extra_fields']:
            for key, value in input_dict.items():
                if key not in valid_dict.keys():
                    valid_dict[key] = value

        return valid_dict","def valid_dict(self): """""" a helper method for ingesting keys, value pairs in a dictionary :return: valid_dict """""" if self._keys: return dict(self._keys) else: return dict(self._keys)",SFT
0.205607476635514,0.17142857142857143,0.205607476635514,0.06569491507212019,0.06569491507212019,0,2.0868096351623535,"def K2onSilicon_main(args=None):
    """"""Function called when `K2onSilicon` is executed on the command line.""""""
    import argparse
    parser = argparse.ArgumentParser(
        description=""Run K2onSilicon to find which targets in a ""
                    ""list call on active silicon for a given K2 campaign."")
    parser.add_argument('csv_file', type=str,
                        help=""Name of input csv file with targets, column are ""
                             ""Ra_degrees, Dec_degrees, Kepmag"")
    parser.add_argument('campaign', type=int, help='K2 Campaign number')
    args = parser.parse_args(args)
    K2onSilicon(args.csv_file, args.campaign)","def execute(self, **kwargs): """""" Function called when K2onSilicon is executed on the command line. """""" kwargs = self.get_kwargs(kwargs, **kwargs) self.get_kwargs(kwargs, **kwargs)",SFT
0.3380281690140845,0.1739130434782609,0.3380281690140845,0.2029311152146656,0.2029311152146656,0,2.0266060829162598,"def qmark(cls, query):
        """"""
        Convert a ""qmark"" query into ""format"" style.
        """"""

        def sub_sequence(m):
            s = m.group(0)
            if s == ""??"":
                return ""?""
            if s == ""%"":
                return ""%%""
            else:
                return ""%s""

        return cls.RE_QMARK.sub(sub_sequence, query)","def format_query(self): """""" Convert a ""qmark"" query into ""format"" style. """""" if self._format_query is None: self._format_query = self._format_query if self._format_query is None: self._format_query = self._format_query",SFT
0.6294416243654822,0.6051282051282051,0.6192893401015228,0.2655320299873903,0.2655320299873903,0,3.4867308139801025,"def FromEncoded(cls, encoded):
        """"""Create a DataStreamSelector from an encoded 16-bit value.

        The binary value must be equivalent to what is produced by
        a call to self.encode() and will turn that value back into
        a a DataStreamSelector.

        Note that the following operation is a no-op:

        DataStreamSelector.FromEncode(value).encode()

        Args:
            encoded (int): The encoded binary representation of a
                DataStreamSelector.

        Returns:
            DataStreamSelector: The decoded selector.
        """"""

        match_spec = encoded & ((1 << 11) | (1 << 15))
        match_type = (encoded & (0b111 << 12)) >> 12
        match_id = encoded & ((1 << 11) - 1)

        if match_spec not in cls.SpecifierEncodingMap:
            raise ArgumentError(""Unknown encoded match specifier"", match_spec=match_spec, known_specifiers=cls.SpecifierEncodingMap.keys())

        spec_name = cls.SpecifierEncodingMap[match_spec]

        # Handle wildcard matches
        if match_id == cls.MatchAllCode:
            match_id = None

        return DataStreamSelector(match_type, match_id, spec_name)","def encode(self, encoded): """"""Create a DataStreamSelector from an encoded 16-bit value. The binary value must be equivalent to what is produced by a call to self.encode() and will turn that value back into a a DataStreamSelector. Note that the following operation is a no-op: DataStreamSelector.FromEncode(value).encode() Args: encoded (int): The encoded binary representation of a DataStreamSelector. Returns: DataStream",SFT
0.48333333333333334,0.38983050847457623,0.44999999999999996,0.3984421423564764,0.3984421423564764,0,3.336625099182129,"def powerstring_by_border(u):
    """"""Power string by Knuth-Morris-Pratt

    :param x: string
    :returns: largest k such that there is a string y with x = y^k
    :complexity: O(len(x))
    """"""
    f = maximum_border_length(u)
    n = len(u)
    if n % (n - f[-1]) == 0:       # does the alignment shift divide n ?
        return n // (n - f[-1])    # we found a power decomposition
    return 1","def power_string(self, x): """"""Power string by Knuth-Morris-Pratt :param x: string :returns: largest k such that there is a string y with x = yk :complexity: O(len(x)) """""" if x is None: if x is None: if x is None: if x is None: if x is None: if y is None: y =",SFT
0.3137254901960784,0.2,0.29411764705882354,0.03108710866320377,0.03108710866320377,0,1.3979110717773438,"def get_fun(fun):
    '''
    Return a dict of the last function called for all minions
    '''
    log.debug('sdstack_etcd returner <get_fun> called fun: %s', fun)
    ret = {}
    client, path = _get_conn(__opts__)
    items = client.get('/'.join((path, 'minions')))
    for item in items.children:
        comps = str(item.key).split('/')
        efun = salt.utils.json.loads(client.get('/'.join((path, 'jobs', str(item.value), comps[-1], 'fun'))).value)
        if efun == fun:
            ret[comps[-1]] = str(efun)
    return ret","def minions(self): """"""Return a dict of the last function called for all minions"""""" if self.minions is None: return dict(self.minions) return dict(self.minions)",SFT
0.4153354632587859,0.3794212218649518,0.4089456869009585,0.03149782844000754,0.03149782844000754,0,3.487217664718628,"def write_csv(
        self, filename, variables=None, alpha=0.05, start=0, batches=100,
            chain=None, quantiles=(2.5, 25, 50, 75, 97.5)):
        """"""
        Save summary statistics to a csv table.

        :Parameters:

        filename : string
          Filename to save output.

        variables : iterable
          List or array of variables for which statistics are to be
          generated. If it is not specified, all the tallied variables
          are summarized.

        alpha : float
          The alpha level for generating posterior intervals. Defaults to
          0.05.

        start : int
          The starting index from which to summarize (each) chain. Defaults
          to zero.

        batches : int
          Batch size for calculating standard deviation for non-independent
          samples. Defaults to 100.

        chain : int
          The index for which chain to summarize. Defaults to None (all
          chains).
        """"""

        # Append 'csv' suffix if there is no suffix on the filename
        if filename.find('.') == -1:
            filename += '.csv'

        outfile = open(filename, 'w')

        # Write header to file
        header = 'Parameter, Mean, SD, MC Error, Lower 95% HPD, Upper 95% HPD, '
        header += ', '.join(['q%s' % i for i in quantiles])
        outfile.write(header + '\n')

        stats = self.stats(
            variables=variables,
            alpha=alpha,
            start=start,
            batches=batches,
            chain=chain,
            quantiles=quantiles)

        if variables is None:
            variables = sorted(stats.keys())

        buffer = str()
        for param in variables:

            values = stats[param]

            try:
                # Multivariate node
                shape = values['mean'].shape
                indices = list(itertools.product(*[range(i) for i in shape]))

                for i in indices:
                    buffer += self._csv_str(param, values, quantiles, i)

            except AttributeError:
                # Scalar node
                buffer += self._csv_str(param, values, quantiles)

        outfile.write(buffer)

        outfile.close()","def save_statistics(filename, variables, alpha=0.05, start=None, batches=None): """"""Save summary statistics to a csv table. :Parameters: filename : string Filename to save output. variables : iterable List or array of variables for which statistics are to be generated. If it is not specified, all the tallied variables are summarized. alpha : float The alpha level for generating posterior intervals. Defaults to 0.05. start : int The",SFT
0.5578231292517007,0.48275862068965514,0.54421768707483,0.19976831758001376,0.19976831758001376,0,3.284167766571045,"def mark_path(path):
    """"""
    Wrap given path as relative path relative to top directory.

    Wrapper object will be handled specially in \
    :paramref:`create_cmd_task.parts`.

    :param path: Relative path relative to top directory.

    :return: Wrapper object.
    """"""
    # If given path is not string,
    # or given path is absolute path.
    if not isinstance(path, str) or os.path.isabs(path):
        # Get error message
        msg = 'Error (2D9ZA): Given path is not relative path: {0}.'.format(
            path
        )

        # Raise error
        raise ValueError(msg)

    # If given path is string,
    # and given path is not absolute path.

    # Wrap given path
    return _ItemWrapper(type='path', item=path)","def wrap(self, path): """"""Wrap given path as relative path relative to top directory. Wrapper object will be handled specially in  :paramref:create_cmd_task.parts. :param path: Relative path relative to top directory. :return: Wrapper object. """""" if path is None: return self._cmd_task.parts(path)",SFT
0.5324675324675325,0.4078947368421053,0.49350649350649345,0.1642832653722063,0.1642832653722063,0,3.2614753246307373,"def rows_to_png(out, rows, size):
    """"""Write to the binary file `out` a single channel 8-bit PNG.
    `rows` should yield each row in turn;
    `size` should be the tuple of (width, height) in pixels.
    """"""

    # Write out PNG signature.
    out.write(bytearray([137, 80, 78, 71, 13, 10, 26, 10]))
    # Write out PNG header chunk.
    header = struct.pack("">2LBBBBB"", size[0], size[1], 8, 0, 0, 0, 0)
    write_chunk(out, b""IHDR"", header)

    bs = bytearray()
    for row in rows:
        bs.append(0)
        bs.extend(row)
    write_chunk(out, b""IDAT"", zlib.compress(bs))

    write_chunk(out, b""IEND"", bytearray())","def _write_to_binary(out, rows, size): """""" Write to the binary file out a single channel 8-bit PNG. rows should yield each row in turn; size should be the tuple of (width, height) in pixels. """""" if isinstance(rows): if isinstance(rows, size): if isinstance(rows, size): if isinstance(rows): if isinstance(row",SFT
0.3829787234042553,0.15217391304347827,0.3829787234042553,0.10128109934605448,0.10128109934605448,0,2.9861690998077393,"def _validate(self):
        """"""
        Validate the input data.
        """"""
        if self.data_format is FormatType.PYTHON:
            self.data = self.raw_data
        elif self.data_format is FormatType.JSON:
            self._validate_json()
        elif self.data_format is FormatType.YAML:
            self._validate_yaml()","def validate(self, data): """"""Validate the input data."""""" if not isinstance(data): raise ValueError(""Input data is not valid"") if not isinstance(data): raise ValueError(""Input data is not valid"") if isinstance(data): raise ValueError(""Input data is not valid"") if isinstance(data): raise ValueError(""Input data is not valid"") if isinstance(data): raise ValueEr",SFT
0.544378698224852,0.31137724550898205,0.47337278106508873,0.15964291531324287,0.15964291531324287,0,3.027132749557495,"def get_resource_manager(self, resource_type, data=None):
        """"""get a resource manager or a given resource type.

        assumes the query is for the same underlying cloud provider.
        """"""
        if '.' in resource_type:
            provider_name, resource_type = resource_type.split('.', 1)
        else:
            provider_name = self.ctx.policy.provider_name

        provider_resources = clouds[provider_name].resources
        klass = provider_resources.get(resource_type)
        if klass is None:
            raise ValueError(resource_type)

        # if we're already querying via config carry it forward
        if not data and self.source_type == 'config' and getattr(
                klass.get_model(), 'config_type', None):
            return klass(self.ctx, {'source': self.source_type})
        return klass(self.ctx, data or {})","def get_resource_manager(self, resource_type): """"""get a resource manager or a given resource type. assumes the query is for the same underlying cloud provider. """""" if self._resource_manager is None: self._resource_manager = self._resource_manager if self._resource_manager is None: self._resource_manager = self._resource_manager if self._resource_manager is None: self._resource_manager = self._resource_",SFT
0.3235294117647059,0.18181818181818185,0.3235294117647059,0.15816512264402116,0.15816512264402116,0,1.7169113159179688,"def update(self, rows):
        """"""
        Updates records in the db
        """"""
        if len(rows) == 0:
            return

        sql, sql_args = self.get_update_sql(rows)

        # get the cursor to execute the query
        cursor = self.get_cursor()

        # execute the query
        cursor.execute(sql, sql_args)","def update_records(self): """"""Updates records in the db"""""" if self._records is None: self._records = self._records if self._records is None: self._records = self._records",SFT
0.48936170212765956,0.26086956521739135,0.42553191489361697,0.09955265142923138,0.09955265142923138,0,1.583735704421997,"def _int_growth(z, **cosmo):
    """""" Returns integral of the linear growth factor from z=200 to z=z """"""

    zmax = 200

    if hasattr(z, ""__len__""):
        for zval in z:
            assert(zval < zmax)
    else:
        assert(z < zmax)

    y, yerr = scipy.integrate.quad(
        lambda z: (1 + z)/(cosmo['omega_M_0']*(1 + z)**3 +
                           cosmo['omega_lambda_0'])**(1.5),
        z, zmax)

    return(y)","def linear_growth_factor(self, z=200): """""" Returns integral of the linear growth factor from z=200 to z=z """""" if z is not None: return self._int(z) return self._int(z)",SFT
0.18840579710144928,0.08823529411764705,0.15942028985507248,0.09736966077720668,0.09736966077720668,0,3.0000014305114746,"def statsd_middleware_factory(app, handler):
    """"""Send the application stats to statsd.""""""
    @coroutine
    def middleware(request):
        """"""Send stats to statsd.""""""
        timer = Timer()
        timer.start()

        statsd = yield from app.ps.metrics.client()
        pipe = statsd.pipe()
        pipe.incr('request.method.%s' % request.method)

        try:
            response = yield from handler(request)
            pipe.incr('response.status.%s' % response.status)
            return response

        except HTTPException as exc:
            pipe.incr('response.status.%s' % exc.status_code)
            raise

        except Exception:
            pipe.incr('response.exception')
            raise

        finally:
            timer.stop()
            pipe.timing('response.time', timer.ms)
            pipe.disconnect()

    return middleware","def send_stats(self, statsd): """"""Send the application stats to statsd."""""" if statsd is None: statsd = self.statsd if statsd is None: statsd = self.statsd if statsd is None: statsd = statsd if statsd is None: statsd = statsd if statsd is None: statsd = statsd if statsd: statsd = statsd if statsd",SFT
0.507177033492823,0.4444444444444444,0.47846889952153104,0.21028675345971617,0.21028675345971617,0,3.332312822341919,"def inpaint(self, win_size=3, rescale_factor=1.0):
        """""" Fills in the zero pixels in the image.

        Parameters
        ----------
        win_size : int
            size of window to use for inpainting
        rescale_factor : float
            amount to rescale the image for inpainting, smaller numbers increase speed

        Returns
        -------
        :obj:`ColorImage`
            color image with zero pixels filled in
        """"""
        # get original shape
        orig_shape = (self.height, self.width)
        
        # resize the image
        resized_data = self.resize(rescale_factor, interp='nearest').data

        # inpaint smaller image
        mask = 1 * (np.sum(resized_data, axis=2) == 0)
        inpainted_data = cv2.inpaint(resized_data, mask.astype(np.uint8),
                                     win_size, cv2.INPAINT_TELEA)
        inpainted_im = ColorImage(inpainted_data, frame=self.frame)

        # fill in zero pixels with inpainted and resized image
        filled_data = inpainted_im.resize(
            orig_shape, interp='bilinear').data
        new_data = self.data
        new_data[self.data == 0] = filled_data[self.data == 0]
        return ColorImage(new_data, frame=self.frame)","def fill_zero_pixels(win_size, rescale_factor): """""" Fills in the zero pixels in the image. Parameters ---------- win_size : int size of window to use for inpainting rescale_factor : float amount to rescale the image for inpainting, smaller numbers increase speed Returns ------- :obj:ColorImage color image with zero pixels filled in """""" if win_size is None: win_size = win_size",SFT
0.06630686198920586,0.06177606177606178,0.06322282189668466,3.4013589574946695e-14,3.4013589574946695e-14,0,3.4778382778167725,"def MCLA(hdf5_file_name, cluster_runs, verbose = False, N_clusters_max = None):
    """"""Meta-CLustering Algorithm for a consensus function.
    
    Parameters
    ----------
    hdf5_file_name : file handle or string
    
    cluster_runs : array of shape (n_partitions, n_samples)
    
    verbose : bool, optional (default = False)
    
    N_clusters_max : int, optional (default = None)
    
    Returns
    -------
    A vector specifying the cluster label to which each sample has been assigned
    by the MCLA approximation algorithm for consensus clustering.

    Reference
    ---------
    A. Strehl and J. Ghosh, ""Cluster Ensembles - A Knowledge Reuse Framework
    for Combining Multiple Partitions"".
    In: Journal of Machine Learning Research, 3, pp. 583-617. 2002
    """"""

    print('\n*****')
    print('INFO: Cluster_Ensembles: MCLA: consensus clustering using MCLA.')

    if N_clusters_max == None:
        N_clusters_max = int(np.nanmax(cluster_runs)) + 1

    N_runs = cluster_runs.shape[0]
    N_samples = cluster_runs.shape[1]

    print(""INFO: Cluster_Ensembles: MCLA: preparing graph for meta-clustering."")

    hypergraph_adjacency = load_hypergraph_adjacency(hdf5_file_name)
    w = hypergraph_adjacency.sum(axis = 1)

    N_rows = hypergraph_adjacency.shape[0]

    print(""INFO: Cluster_Ensembles: MCLA: done filling hypergraph adjacency matrix. ""
          ""Starting computation of Jaccard similarity matrix."")

    # Next, obtain a matrix of pairwise Jaccard similarity scores between the rows of the hypergraph adjacency matrix.
    with tables.open_file(hdf5_file_name, 'r+') as fileh:
        FILTERS = get_compression_filter(4 * (N_rows ** 2))
    
        similarities_MCLA = fileh.create_carray(fileh.root.consensus_group, 
                                   'similarities_MCLA', tables.Float32Atom(), 
                                   (N_rows, N_rows), ""Matrix of pairwise Jaccard ""
                                   ""similarity scores"", filters = FILTERS)

        scale_factor = 100.0

        print(""INFO: Cluster_Ensembles: MCLA: ""
              ""starting computation of Jaccard similarity matrix."")

        squared_MCLA = hypergraph_adjacency.dot(hypergraph_adjacency.transpose())

        squared_sums = hypergraph_adjacency.sum(axis = 1)
        squared_sums = np.squeeze(np.asarray(squared_sums))

        chunks_size = get_chunk_size(N_rows, 7)
        for i in range(0, N_rows, chunks_size):
            n_dim = min(chunks_size, N_rows - i)

            temp = squared_MCLA[i:min(i+chunks_size, N_rows), :].todense()
            temp = np.squeeze(np.asarray(temp))

            x = squared_sums[i:min(i+chunks_size, N_rows)]
            x = x.reshape(-1, 1)
            x = np.dot(x, np.ones((1, squared_sums.size)))

            y = np.dot(np.ones((n_dim, 1)), squared_sums.reshape(1, -1))
        
            temp = np.divide(temp, x + y - temp)
            temp *= scale_factor

            Jaccard_matrix = np.rint(temp)
            similarities_MCLA[i:min(i+chunks_size, N_rows)] = Jaccard_matrix

            del Jaccard_matrix, temp, x, y
            gc.collect()
 
    # Done computing the matrix of pairwise Jaccard similarity scores.
    print(""INFO: Cluster_Ensembles: MCLA: done computing the matrix of ""
          ""pairwise Jaccard similarity scores."")

    cluster_labels = cmetis(hdf5_file_name, N_clusters_max, w)
    cluster_labels = one_to_max(cluster_labels)
    # After 'cmetis' returns, we are done with clustering hyper-edges

    # We are now ready to start the procedure meant to collapse meta-clusters.
    N_consensus = np.amax(cluster_labels) + 1

    fileh = tables.open_file(hdf5_file_name, 'r+')

    FILTERS = get_compression_filter(4 * N_consensus * N_samples)
    
    clb_cum = fileh.create_carray(fileh.root.consensus_group, 'clb_cum', 
                                  tables.Float32Atom(), (N_consensus, N_samples), 
                                  'Matrix of mean memberships, forming meta-clusters', 
                                  filters = FILTERS)  
 
    chunks_size = get_chunk_size(N_samples, 7)
    for i in range(0, N_consensus, chunks_size):
        x = min(chunks_size, N_consensus - i)
        matched_clusters = np.where(cluster_labels == np.reshape(np.arange(i, min(i + chunks_size, N_consensus)), newshape = (x, 1)))
        M = np.zeros((x, N_samples))
        for j in range(x):
            coord = np.where(matched_clusters[0] == j)[0]
            M[j] = np.asarray(hypergraph_adjacency[matched_clusters[1][coord], :].mean(axis = 0))
        clb_cum[i:min(i+chunks_size, N_consensus)] = M
    
    # Done with collapsing the hyper-edges into a single meta-hyper-edge, 
    # for each of the (N_consensus - 1) meta-clusters.

    del hypergraph_adjacency
    gc.collect()

    # Each object will now be assigned to its most associated meta-cluster.
    chunks_size = get_chunk_size(N_consensus, 4)
    N_chunks, remainder = divmod(N_samples, chunks_size)
    if N_chunks == 0:
        null_columns = np.where(clb_cum[:].sum(axis = 0) == 0)[0]
    else:
        szumsz = np.zeros(0)
        for i in range(N_chunks):
            M = clb_cum[:, i*chunks_size:(i+1)*chunks_size]
            szumsz = np.append(szumsz, M.sum(axis = 0))
        if remainder != 0:
            M = clb_cum[:, N_chunks*chunks_size:N_samples]
            szumsz = np.append(szumsz, M.sum(axis = 0))
        null_columns = np.where(szumsz == 0)[0]

    if null_columns.size != 0:
        print(""INFO: Cluster_Ensembles: MCLA: {} objects with all zero associations ""
              ""in 'clb_cum' matrix of meta-clusters."".format(null_columns.size))
        clb_cum[:, null_columns] = np.random.rand(N_consensus, null_columns.size)

    random_state = np.random.RandomState()

    tmp = fileh.create_carray(fileh.root.consensus_group, 'tmp', tables.Float32Atom(),
                              (N_consensus, N_samples), ""Temporary matrix to help with ""
                              ""collapsing to meta-hyper-edges"", filters = FILTERS)

    chunks_size = get_chunk_size(N_samples, 2)
    N_chunks, remainder = divmod(N_consensus, chunks_size)
    if N_chunks == 0:
        tmp[:] = random_state.rand(N_consensus, N_samples)
    else:
        for i in range(N_chunks):
            tmp[i*chunks_size:(i+1)*chunks_size] = random_state.rand(chunks_size, N_samples)
        if remainder !=0:
            tmp[N_chunks*chunks_size:N_consensus] = random_state.rand(remainder, N_samples)

    expr = tables.Expr(""clb_cum + (tmp / 10000)"")
    expr.set_output(clb_cum)
    expr.eval()

    expr = tables.Expr(""abs(tmp)"")
    expr.set_output(tmp)
    expr.eval()

    chunks_size = get_chunk_size(N_consensus, 2)
    N_chunks, remainder = divmod(N_samples, chunks_size)
    if N_chunks == 0:
        sum_diag = tmp[:].sum(axis = 0)
    else:
        sum_diag = np.empty(0)
        for i in range(N_chunks):
            M = tmp[:, i*chunks_size:(i+1)*chunks_size]
            sum_diag = np.append(sum_diag, M.sum(axis = 0))
        if remainder != 0:
            M = tmp[:, N_chunks*chunks_size:N_samples]
            sum_diag = np.append(sum_diag, M.sum(axis = 0))

    fileh.remove_node(fileh.root.consensus_group, ""tmp"") 
    # The corresponding disk space will be freed after a call to 'fileh.close()'.

    inv_sum_diag = np.reciprocal(sum_diag.astype(float))

    if N_chunks == 0:
        clb_cum *= inv_sum_diag
        max_entries = np.amax(clb_cum, axis = 0)
    else:
        max_entries = np.zeros(N_samples)
        for i in range(N_chunks):
            clb_cum[:, i*chunks_size:(i+1)*chunks_size] *= inv_sum_diag[i*chunks_size:(i+1)*chunks_size]
            max_entries[i*chunks_size:(i+1)*chunks_size] = np.amax(clb_cum[:, i*chunks_size:(i+1)*chunks_size], axis = 0)
        if remainder != 0:
            clb_cum[:, N_chunks*chunks_size:N_samples] *= inv_sum_diag[N_chunks*chunks_size:N_samples]
            max_entries[N_chunks*chunks_size:N_samples] = np.amax(clb_cum[:, N_chunks*chunks_size:N_samples], axis = 0)

    cluster_labels = np.zeros(N_samples, dtype = int)
    winner_probabilities = np.zeros(N_samples)
    
    chunks_size = get_chunk_size(N_samples, 2)
    for i in reversed(range(0, N_consensus, chunks_size)):
        ind = np.where(np.tile(max_entries, (min(chunks_size, N_consensus - i), 1)) == clb_cum[i:min(i+chunks_size, N_consensus)])
        cluster_labels[ind[1]] = i + ind[0]
        winner_probabilities[ind[1]] = clb_cum[(ind[0] + i, ind[1])]       

    # Done with competing for objects.

    cluster_labels = one_to_max(cluster_labels)

    print(""INFO: Cluster_Ensembles: MCLA: delivering ""
          ""{} clusters."".format(np.unique(cluster_labels).size))
    print(""INFO: Cluster_Ensembles: MCLA: average posterior ""
          ""probability is {}"".format(np.mean(winner_probabilities)))
    if cluster_labels.size <= 7:
        print(""INFO: Cluster_Ensembles: MCLA: the winning posterior probabilities are:"")
        print(winner_probabilities)
        print(""'INFO: Cluster_Ensembles: MCLA: the full posterior probabilities are:"")
        print(clb_cum)

    fileh.remove_node(fileh.root.consensus_group, ""clb_cum"")
    fileh.close()

    return cluster_labels","def meta_clustering(hdf5_file_name, cluster_runs, verbose=False, N_clusters_max=None): """""" Meta-CLustering Algorithm for a consensus function. Parameters ---------- hdf5_file_name : file handle or string cluster_runs : array of shape (n_partitions, n_samples) verbose : bool, optional (default = False)",SFT
0.6860465116279071,0.6352941176470588,0.6744186046511628,0.255836814015479,0.255836814015479,0,3.493572235107422,"def nice_join(seq, sep="", "", conjuction=""or""):
    ''' Join together sequences of strings into English-friendly phrases using
    the conjunction ``or`` when appropriate.

    Args:
        seq (seq[str]) : a sequence of strings to nicely join
        sep (str, optional) : a sequence delimiter to use (default: "", "")
        conjunction (str or None, optional) : a conjuction to use for the last
            two items, or None to reproduce basic join behaviour (default: ""or"")

    Returns:
        a joined string

    Examples:
        >>> nice_join([""a"", ""b"", ""c""])
        'a, b or c'

    '''
    seq = [str(x) for x in seq]

    if len(seq) <= 1 or conjuction is None:
        return sep.join(seq)
    else:
        return ""%s %s %s"" % (sep.join(seq[:-1]), conjuction, seq[-1])","def join(self, seq, sep=None, conjunction=None): """""" Join together sequences of strings into English-friendly phrases using the conjunction or when appropriate. Args: seq (seq[str]) : a sequence of strings to nicely join sep (str, optional) : a sequence delimiter to use (default: "", "") conjunction (str or None, optional) : a conjuction to use for the last two items, or None to reproduce basic",SFT
0.3841059602649006,0.36666666666666664,0.3841059602649006,0.030280602864385147,0.030280602864385147,0,3.4867897033691406,"def get_option(
            self,
            section_name,
            key_name,
            args_option=None,
            args_default=None,
    ):
        """"""evaluates the requested option and returns the correct value

        Notes:
            Priority order
            1. args given at runtile
            2. <config_file>_local.cfg -- untracked config with #SECRETS
            3. <config_file>.cfg -- tracked 'master' config without #SECRETS
            4. environment varabile
            5. args_default -- function default w/o global config

        Args:
            section_name (str): section level name in config
            key_name (str): key name for option in config
            args_option (any): arg option given by a function
            args_default (any): arg default given by a function

        Returns:
            str: appropriate response as per priority order

        """"""
        if args_option != args_default and\
           args_option is not None:
            self.logger.debug('-- using function args')
            return args_option

        section_info = section_name + '.' + key_name

        option = None
        try:
            option = check_value(self.local_config, section_name, key_name)
            self.logger.debug('-- using local config')
            if option:
                return option
        except (KeyError, configparser.NoOptionError, configparser.NoSectionError):
            self.logger.debug('`%s` not found in local config', section_info)

        try:
            option = check_value(self.global_config, section_name, key_name)
            self.logger.debug('-- using global config')
            if option:
                return option
        except (KeyError, configparser.NoOptionError, configparser.NoSectionError):
            self.logger.warning('`%s` not found in global config', section_info)

        env_option = get_value_from_environment(section_name, key_name, logger=self.logger)
        if env_option:
            self.logger.debug('-- using environment value')
            return env_option

        self.logger.debug('-- using default argument')
        return args_default","def evaluate_option(self, section_name, key_name): """""" evaluates the requested option and returns the correct value Notes: Priority order 1. args given at runtile 2. config_file>_local.cfg -- untracked config with #SECRETS 3. config_file>.cfg -- tracked 'master' config without #SECRETS 4. environment varabile 5. args_default -- function default w/o global config Args: section_name (str",SFT
0.35625,0.3333333333333333,0.34375,0.029101693912172103,0.029101693912172103,0,3.4924447536468506,"def write_observation_zone(self, **kw):
        """"""
        Write an observation zone declaration to the file::

            writer.write_observation_zone(
                type=ObservationZoneType.CYLINDER,
                radius=30000,
            )

            # <ObservationZone type=""Cylinder"" radius=""30000""/>

        The required parameters depend on the type parameter. Different
        observation zone types require different parameters.

        :param type: observation zone type (one of the constants in
            :class:`~aerofiles.xcsoar.constants.ObservationZoneType`)

        :param length: length of the line
            (only used with type
            :const:`~aerofiles.xcsoar.constants.ObservationZoneType.LINE`)
        :param radius: (outer) radius of the observation zone
            (used with types
            :const:`~aerofiles.xcsoar.constants.ObservationZoneType.CYLINDER`,
            :const:`~aerofiles.xcsoar.constants.ObservationZoneType.SECTOR`,
            :const:`~aerofiles.xcsoar.constants.ObservationZoneType.SYMMETRIC_QUADRANT` and
            :const:`~aerofiles.xcsoar.constants.ObservationZoneType.CUSTOM_KEYHOLE`)
        :param inner_radius: inner radius of the observation zone
            (only used with type
            :const:`~aerofiles.xcsoar.constants.ObservationZoneType.CUSTOM_KEYHOLE`)
        :param angle: angle of the observation zone
            (only used with type
            :const:`~aerofiles.xcsoar.constants.ObservationZoneType.CUSTOM_KEYHOLE`)
        :param start_radial: start radial of the observation zone
            (only used with type
            :const:`~aerofiles.xcsoar.constants.ObservationZoneType.SECTOR`)
        :param end_radial: end radial of the observation zone
            (only used with type
            :const:`~aerofiles.xcsoar.constants.ObservationZoneType.SECTOR`)
        """"""

        assert 'type' in kw

        if kw['type'] == ObservationZoneType.LINE:
            assert 'length' in kw

        elif kw['type'] == ObservationZoneType.CYLINDER:
            assert 'radius' in kw

        elif kw['type'] == ObservationZoneType.SECTOR:
            assert 'radius' in kw
            assert 'start_radial' in kw
            assert 'end_radial' in kw

        elif kw['type'] == ObservationZoneType.SYMMETRIC_QUADRANT:
            assert 'radius' in kw

        elif kw['type'] == ObservationZoneType.CUSTOM_KEYHOLE:
            assert 'radius' in kw
            assert 'inner_radius' in kw
            assert 'angle' in kw

        self.write_tag('ObservationZone', **kw)","def write_observation_zone(self, type, length): """""" Write an observation zone declaration to the file:: writer.write_observation_zone( type=ObservationZoneType.CYLINDER, radius=30000, ) # ObservationZone type=""Cylinder"" radius=""30000""/> The required parameters depend on the type parameter. Different observation zone types require different parameters. :param type: observation zone type (one of the constants in :class:aerofiles.xcsoar",SFT
0.7826086956521738,0.6444444444444444,0.7608695652173912,0.4425899817582587,0.4425899817582587,0,3.2335519790649414,"def char(self, c: str) -> None:
        """"""Parse the specified character.

        Args:
            c: One-character string.

        Raises:
            EndOfInput: If past the end of `self.input`.
            UnexpectedInput: If the next character is different from `c`.
        """"""
        if self.peek() == c:
            self.offset += 1
        else:
            raise UnexpectedInput(self, f""char '{c}'"")","def parse(self, c): """"""Parse the specified character. Args: c: One-character string. Raises: EndOfInput: If past the end of self.input. UnexpectedInput: If the next character is different from c. """""" if self.input is None: self.input = self.input else: self.input = self.input",SFT
0.3630769230769231,0.34674922600619196,0.3569230769230769,0.018857132304278355,0.018857132304278355,0,3.5116324424743652,"def deprecated(*args, **kwargs):
    """"""
    This is a decorator which can be used to mark functions
    as deprecated. It will result in a warning being emitted
    when the function is used.

    **Classic usage:**

    To use this, decorate your deprecated function with **@deprecated** decorator:

    .. code-block:: python

       from deprecated import deprecated


       @deprecated
       def some_old_function(x, y):
           return x + y

    You can also decorate a class or a method:

    .. code-block:: python

       from deprecated import deprecated


       class SomeClass(object):
           @deprecated
           def some_old_method(self, x, y):
               return x + y


       @deprecated
       class SomeOldClass(object):
           pass

    You can give a ""reason"" message to help the developer to choose another function/class,
    and a ""version"" number to specify the starting version number of the deprecation.

    .. code-block:: python

       from deprecated import deprecated


       @deprecated(reason=""use another function"", version='1.2.0')
       def some_old_function(x, y):
           return x + y

    """"""
    if args and isinstance(args[0], string_types):
        kwargs['reason'] = args[0]
        args = args[1:]

    if args and not callable(args[0]):
        raise TypeError(repr(type(args[0])))

    if args:
        action = kwargs.get('action', 'always')
        category = kwargs.get('category', DeprecationWarning)
        adapter_cls = kwargs.pop('adapter_cls', ClassicAdapter)
        adapter = adapter_cls(**kwargs)

        wrapped = args[0]
        if inspect.isclass(wrapped):
            wrapped = adapter(wrapped)
            return wrapped

        elif inspect.isroutine(wrapped):

            @wrapt.decorator(adapter=adapter)
            def wrapper_function(wrapped_, instance_, args_, kwargs_):
                msg = adapter.get_deprecated_msg(wrapped_, instance_)
                with warnings.catch_warnings():
                    warnings.simplefilter(action, category)
                    warnings.warn(msg, category=category, stacklevel=2)
                return wrapped_(*args_, **kwargs_)

            return wrapper_function(wrapped)

        else:
            raise TypeError(repr(type(wrapped)))

    return functools.partial(deprecated, **kwargs)","def deprecated(self): ''' This is a decorator which can be used to mark functions as deprecated. It will result in a warning being emitted when the function is used. **Classic usage:** To use this, decorate your deprecated function with **@deprecated** decorator: .. code-block:: python from deprecated import deprecated @deprecated def some_old_function(x, y): return x + y You",SFT
0.6442307692307693,0.6213592233009709,0.6346153846153846,0.2779458644876233,0.2779458644876233,0,3.659883975982666,"def configure_from_environment(self, whitelist_keys=False, whitelist=None):
        """"""Configure from the entire set of available environment variables.

        This is really a shorthand for grabbing ``os.environ`` and passing to
        :meth:`_configure_from_mapping`.

        As always, only uppercase keys are loaded.

        Keyword Args:
            whitelist_keys (bool):
                Should we whitelist the keys by only pulling those that are
                already present in the config? Useful for avoiding adding
                things like ``LESSPIPE`` to your app config. If no whitelist is
                provided, we use the current config keys as our whitelist.
            whitelist (list[str]):
                An explicit list of keys that should be allowed. If provided
                and ``whitelist_keys`` is true, we will use that as our
                whitelist instead of pre-existing app config keys.

        Returns:
            fleaker.base.BaseApplication:
                Returns itself.
        """"""
        self._configure_from_mapping(os.environ, whitelist_keys=whitelist_keys,
                                     whitelist=whitelist)

        return self","def configure_from_mapping(self, whitelist_keys=False): """"""Configure from the entire set of available environment variables. This is really a shorthand for grabbing os.environ and passing to :meth:_configure_from_mapping. As always, only uppercase keys are loaded. Keyword Args: whitelist_keys (bool): Should we whitelist the keys by only pulling those that are already present in the config? Useful for avoiding adding things like",SFT
0.24649859943977592,0.16338028169014085,0.23529411764705882,0.0015067551274590507,0.0015067551274590507,0,3.441646099090576,"def parseDate(self, dateString):
        """"""
        Parse short-form date strings::

            '05/28/2006' or '04.21'

        @type  dateString: string
        @param dateString: text to convert to a C{datetime}

        @rtype:  struct_time
        @return: calculated C{struct_time} value of dateString
        """"""
        yr, mth, dy, hr, mn, sec, wd, yd, isdst = time.localtime()

        # values pulled from regex's will be stored here and later
        # assigned to mth, dy, yr based on information from the locale
        # -1 is used as the marker value because we want zero values
        # to be passed thru so they can be flagged as errors later
        v1 = -1
        v2 = -1
        v3 = -1

        s = dateString
        m = self.ptc.CRE_DATE2.search(s)
        if m is not None:
            index = m.start()
            v1    = int(s[:index])
            s     = s[index + 1:]

        m = self.ptc.CRE_DATE2.search(s)
        if m is not None:
            index = m.start()
            v2    = int(s[:index])
            v3    = int(s[index + 1:])
        else:
            v2 = int(s.strip())

        v = [ v1, v2, v3 ]
        d = { 'm': mth, 'd': dy, 'y': yr }

        for i in range(0, 3):
            n = v[i]
            c = self.ptc.dp_order[i]
            if n >= 0:
                d[c] = n

        # if the year is not specified and the date has already
        # passed, increment the year
        if v3 == -1 and ((mth > d['m']) or (mth == d['m'] and dy > d['d'])):
            yr = d['y'] + 1
        else:
            yr  = d['y']

        mth = d['m']
        dy  = d['d']

        # birthday epoch constraint
        if yr < self.ptc.BirthdayEpoch:
            yr += 2000
        elif yr < 100:
            yr += 1900

        if _debug:
            print 'parseDate: ', yr, mth, dy, self.ptc.daysInMonth(mth, yr)

        if (mth > 0 and mth <= 12) and \
           (dy > 0 and dy <= self.ptc.daysInMonth(mth, yr)):
            sourceTime = (yr, mth, dy, hr, mn, sec, wd, yd, isdst)
        else:
            self.dateFlag = 0
            self.timeFlag = 0
            sourceTime    = time.localtime() # return current time if date
                                             # string is invalid

        return sourceTime","def parse_short_form_date(self, dateString): """""" Parse short-form date strings:: '05/28/2006' or '04.21' @type dateString: string @param dateString: text to convert to a Cdatetime @rtype: struct_time @return: calculated Cstruct_time value of dateString """""" if dateString is None: if dateString is None: if dateString is None: if dateStr",SFT
0.5211267605633804,0.4285714285714286,0.5211267605633804,0.21676096081918905,0.21676096081918905,0,3.217754364013672,"def _get_base_command(self):
        """"""Returns the base command plus command-line options.

        Handles everything up to and including the classpath.  The
        positional training parameters are added by the
        _input_handler_decorator method.
        """"""
        cd_command = ''.join(['cd ', str(self.WorkingDir), ';'])
        jvm_command = ""java""
        jvm_args = self._commandline_join(
            [self.Parameters[k] for k in self._jvm_parameters])
        cp_args = '-cp ""%s"" %s' % (self._get_jar_fp(), self.TrainingClass)

        command_parts = [cd_command, jvm_command, jvm_args, cp_args]
        return self._commandline_join(command_parts).strip()","def base_command(self): """""" Returns the base command plus command-line options. Handles everything up to and including the classpath. The positional training parameters are added by the _input_handler_decorator method. """""" if self._input_handler_decorator is None: self._input_handler_decorator = self._input_handler_decorator if self._input_handler_decorator is None: self._input_handler_",SFT
0.3859649122807018,0.2909090909090909,0.3859649122807018,0.34462428880107054,0.34462428880107054,0,2.2048816680908203,"def heappush(heap, item):
    """"""Push item onto heap, maintaining the heap invariant.""""""
    heap.append(item)
    _siftdown(heap, 0, len(heap)-1)","def push(self, item): """"""Push item onto heap, maintaining the heap invariant."""""" if item not in self.items: self.items[item] = self.items[item] self.items[item] = self.items[item] self.items[item] = self.items[item]",SFT
0.6551724137931034,0.6347826086956522,0.6551724137931034,0.3106864156706408,0.3106864156706408,0,3.44328236579895,"def remove_callback(self, name, before=None, after=None):
        """"""Remove a beforeback, and afterback pair from this Spectator

        If ``before`` and ``after`` are None then all callbacks for
        the given method will be removed. Otherwise, only the exact
        callback pair will be removed.

        Parameters
        ----------
        name: str
            The name of the method the callback pair is associated with.
        before: None or callable
            The beforeback that was originally registered to the given method.
        after: None or callable
            The afterback that was originally registered to the given method.
        """"""
        if isinstance(name, (list, tuple)):
            for name in name:
                self.remove_callback(name, before, after)
        elif before is None and after is None:
            del self._callback_registry[name]
        else:
            if name in self._callback_registry:
                callback_list = self._callback_registry[name]
            else:
                callback_list = []
                self._callback_registry[name] = callback_list
            callback_list.remove((before, after))
            if len(callback_list) == 0:
                # cleanup if all callbacks are gone
                del self._callback_registry[name]","def remove(self, name, before=None, after=None): """"""Remove a beforeback, and afterback pair from this Spectator If before and after are None then all callbacks for the given method will be removed. Otherwise, only the exact callback pair will be removed. Parameters ---------- name: str The name of the method the callback pair is associated with. before: None or callable The beforeback that was originally registered to the given method. after: None or callable The after",SFT
0.12997903563941302,0.1094736842105263,0.12578616352201258,5.8149670456901824e-05,5.8149670456901824e-05,0,3.3701043128967285,"def rpn_losses(anchor_labels, anchor_boxes, label_logits, box_logits):
    """"""
    Args:
        anchor_labels: fHxfWxNA
        anchor_boxes: fHxfWxNAx4, encoded
        label_logits:  fHxfWxNA
        box_logits: fHxfWxNAx4

    Returns:
        label_loss, box_loss
    """"""
    with tf.device('/cpu:0'):
        valid_mask = tf.stop_gradient(tf.not_equal(anchor_labels, -1))
        pos_mask = tf.stop_gradient(tf.equal(anchor_labels, 1))
        nr_valid = tf.stop_gradient(tf.count_nonzero(valid_mask, dtype=tf.int32), name='num_valid_anchor')
        nr_pos = tf.identity(tf.count_nonzero(pos_mask, dtype=tf.int32), name='num_pos_anchor')
        # nr_pos is guaranteed >0 in C4. But in FPN. even nr_valid could be 0.

        valid_anchor_labels = tf.boolean_mask(anchor_labels, valid_mask)
    valid_label_logits = tf.boolean_mask(label_logits, valid_mask)

    with tf.name_scope('label_metrics'):
        valid_label_prob = tf.nn.sigmoid(valid_label_logits)
        summaries = []
        with tf.device('/cpu:0'):
            for th in [0.5, 0.2, 0.1]:
                valid_prediction = tf.cast(valid_label_prob > th, tf.int32)
                nr_pos_prediction = tf.reduce_sum(valid_prediction, name='num_pos_prediction')
                pos_prediction_corr = tf.count_nonzero(
                    tf.logical_and(
                        valid_label_prob > th,
                        tf.equal(valid_prediction, valid_anchor_labels)),
                    dtype=tf.int32)
                placeholder = 0.5   # A small value will make summaries appear lower.
                recall = tf.cast(tf.truediv(pos_prediction_corr, nr_pos), tf.float32)
                recall = tf.where(tf.equal(nr_pos, 0), placeholder, recall, name='recall_th{}'.format(th))
                precision = tf.cast(tf.truediv(pos_prediction_corr, nr_pos_prediction), tf.float32)
                precision = tf.where(tf.equal(nr_pos_prediction, 0),
                                     placeholder, precision, name='precision_th{}'.format(th))
                summaries.extend([precision, recall])
        add_moving_summary(*summaries)

    # Per-level loss summaries in FPN may appear lower due to the use of a small placeholder.
    # But the total RPN loss will be fine.  TODO make the summary op smarter
    placeholder = 0.
    label_loss = tf.nn.sigmoid_cross_entropy_with_logits(
        labels=tf.cast(valid_anchor_labels, tf.float32), logits=valid_label_logits)
    label_loss = tf.reduce_sum(label_loss) * (1. / cfg.RPN.BATCH_PER_IM)
    label_loss = tf.where(tf.equal(nr_valid, 0), placeholder, label_loss, name='label_loss')

    pos_anchor_boxes = tf.boolean_mask(anchor_boxes, pos_mask)
    pos_box_logits = tf.boolean_mask(box_logits, pos_mask)
    delta = 1.0 / 9
    box_loss = tf.losses.huber_loss(
        pos_anchor_boxes, pos_box_logits, delta=delta,
        reduction=tf.losses.Reduction.SUM) / delta
    box_loss = box_loss * (1. / cfg.RPN.BATCH_PER_IM)
    box_loss = tf.where(tf.equal(nr_pos, 0), placeholder, box_loss, name='box_loss')

    add_moving_summary(label_loss, box_loss, nr_valid, nr_pos)
    return [label_loss, box_loss]","def label_loss(self, anchor_labels, anchor_boxes, encoded_label_logits, box_logits): """""" Args: anchor_labels: fHxfWxNA anchor_boxes: fHxfWxNAx4, encoded label_logits: fHxfWxNA box_logits: fHxfWxNAx4 Returns: label_loss, box_loss """""" if encoded_labels:",SFT
0.44000000000000006,0.1836734693877551,0.4,0.05674243596330923,0.05674243596330923,0,1.6843416690826416,"def _should_defer(input_layer, args, kwargs):
  """"""Checks to see if any of the args are templates.""""""
  for arg in itertools.chain([input_layer], args, six.itervalues(kwargs)):
    if isinstance(arg, (_DeferredLayer, UnboundVariable)):
      return True
    elif (isinstance(arg, collections.Sequence) and
          not isinstance(arg, six.string_types)):
      if _should_defer(None, arg, {}):
        return True
    elif isinstance(arg, collections.Mapping):
      if _should_defer(None, (), arg):
        return True
  return False","def check_args(self): """""" Checks to see if any of the args are templates. """""" if self._args is None: self._args = self._args if self._args is None: self._args = self._args",SFT
0.43859649122807015,0.23214285714285715,0.43859649122807015,0.06921426364448104,0.06921426364448104,0,2.1117167472839355,"def corelinkformat(resource):
        """"""
        Return a formatted string representation of the corelinkformat in the tree.

        :return: the string
        """"""
        msg = ""<"" + resource.path + "">;""
        assert(isinstance(resource, Resource))
        keys = sorted(list(resource.attributes.keys()))
        for k in keys:
            method = getattr(resource, defines.corelinkformat[k], None)
            if method is not None and method != """":
                v = method
                msg = msg[:-1] + "";"" + str(v) + "",""
            else:
                v = resource.attributes[k]
                if v is not None:
                    msg = msg[:-1] + "";"" + k + ""="" + v + "",""
        return msg","def _get_corelinkformat(self): """""" Return a formatted string representation of the corelinkformat in the tree. :return: the string """""" if self.corelinkformat is None: return self.corelinkformat if self.corelinkformat is None: return self.corelinkformat if self.corelinkformat is None: return self.corelinkformat",SFT
0.36619718309859156,0.3188405797101449,0.36619718309859156,0.31900680521894204,0.31900680521894204,0,3.161794424057007,"def contourf(x, y, z, ax, **kwargs):
    """"""
    Filled contour plot of 2d DataArray

    Wraps :func:`matplotlib:matplotlib.pyplot.contourf`
    """"""
    primitive = ax.contourf(x, y, z, **kwargs)
    return primitive","def contour_plot(self): """""" Filled contour plot of 2d DataArray Wraps :func:matplotlib:matplotlib.pyplot.contourf """""" if self._contour_plot is None: self._contour_plot = self._contour_plot if self._contour_plot is None: self._contour_plot = self._contour_plot if self._contour_",SFT
0.6333333333333334,0.5862068965517241,0.6333333333333334,0.4828648416045473,0.4828648416045473,0,1.5326871871948242,"def blink(self, blink):
        """"""Turn on or off cursor blinking.  Set blink to True to enable blinking.""""""
        if blink:
            self.displaycontrol |= LCD_BLINKON
        else:
            self.displaycontrol &= ~LCD_BLINKON
        self.write8(LCD_DISPLAYCONTROL | self.displaycontrol)","def blink(self, blink=False): """""" Turn on or off cursor blinking. Set blink to True to enable blinking. """""" if blink is None: return False return False",SFT
0.5306122448979591,0.3404255319148936,0.5306122448979591,0.3510665553361761,0.3510665553361761,0,1.5422968864440918,"def _clear_config(self):
        # type: () -> None
        """"""Clearout config object in memory.""""""
        for section in self._config.sections():
            self._config.remove_section(section)","def clear_config(self, config): """"""Clearout config object in memory."""""" config = self.get_config(config) self.get_config(config) self.get_config(config) self.get_config(config)",SFT
0.7857142857142856,0.6585365853658537,0.7857142857142856,0.5983966367218295,0.5983966367218295,0,3.210684061050415,"def unregistercls(self, schemacls=None, data_types=None):
    """"""Unregister schema class or associated data_types.

    :param type schemacls: sub class of Schema.
    :param list data_types: data_types to unregister.
    """"""
    return _REGISTRY.unregistercls(schemacls=schemacls, data_types=data_types)","def unregister_schema(self, schemacls, data_types): """"""Unregister schema class or associated data_types. :param type schemacls: sub class of Schema. :param list data_types: data_types to unregister. """""" schemacls = schemacls.unregister(data_types) if schemacls.unregister(data_types): schemacls.unregister(data_types) schemacls.un",SFT
0.7216494845360826,0.7083333333333334,0.7216494845360826,0.3523661881550442,0.3523661881550442,0,3.4639365673065186,"def md_to_pdf(input_name, output_name):
    """"""
    Converts an input MarkDown file to a PDF of the given output name.

    Parameters
    ==========
    input_name : String
    Relative file location of the input file to where this function is being called.

    output_name : String
    Relative file location of the output file to where this function is being called. Note that .pdf can be omitted.

    Examples
    ========
    Suppose we have a directory as follows:
    data/
        doc.md
    
    To convert the document:
    >>> from aide_document import convert
    >>> convert.md_to_pdf('data/doc.md', 'data/doc.pdf')

    .pdf can also be omitted from the second argument.
    """"""

    if output_name[-4:] == '.pdf':
        os.system(""pandoc "" + input_name + "" -o "" + output_name)
    else:
        os.system(""pandoc "" + input_name + "" -o "" + output_name + "".pdf"" )","def to_pdf(input_name, output_name): """""" Converts an input MarkDown file to a PDF of the given output name. Parameters ======== input_name : String Relative file location of the input file to where this function is being called. output_name : String Relative file location of the output file to where this function is being called. Note that .pdf can be omitted. Examples ======== Suppose we have a directory as follows: data/",SFT
0.6896551724137931,0.6511627906976745,0.6666666666666666,0.4002834260978078,0.4002834260978078,0,3.4930579662323,"def create_socketpair(size=None):
    """"""
    Create a :func:`socket.socketpair` to use for use as a child process's UNIX
    stdio channels. As socket pairs are bidirectional, they are economical on
    file descriptor usage as the same descriptor can be used for ``stdin`` and
    ``stdout``. As they are sockets their buffers are tunable, allowing large
    buffers to be configured in order to improve throughput for file transfers
    and reduce :class:`mitogen.core.Broker` IO loop iterations.
    """"""
    parentfp, childfp = socket.socketpair()
    parentfp.setsockopt(socket.SOL_SOCKET,
                        socket.SO_SNDBUF,
                        size or mitogen.core.CHUNK_SIZE)
    childfp.setsockopt(socket.SOL_SOCKET,
                       socket.SO_RCVBUF,
                       size or mitogen.core.CHUNK_SIZE)
    return parentfp, childfp","def socket_pair(self, socket_pair): """"""Create a :func:socket.socketpair to use for use as a child process's UNIX stdio channels. As socket pairs are bidirectional, they are economical on file descriptor usage as the same descriptor can be used for stdin and stdout. As they are sockets their buffers are tunable, allowing large buffers to be configured in order to",SFT
0.6101694915254238,0.456140350877193,0.6101694915254238,0.6165495925034651,0.6165495925034651,0,1.9750611782073975,"def Message(self, text):
        """"""Inform about what we are doing right now, e.g.
        'Checking for SOMETHING ... '
        """"""
        self.Display(text)
        self.sconf.cached = 1
        self.did_show_result = 0","def check_for_somthing(self): """""" Inform about what we are doing right now, e.g. 'Checking for SOMETHING ... ' """""" self._check_for_somthing(self._check_for_somthing(self._check_for_somthing))",SFT
0.4666666666666667,0.33898305084745767,0.45,0.3953120642276639,0.3953120642276639,0,3.1926522254943848,"def _speak_as_no_punctuation_inherit(self, element):
        """"""
        No speak the punctuation for element and descendants.

        :param element: The element.
        :type element: hatemile.util.html.htmldomelement.HTMLDOMElement
        """"""

        self._reverse_speak_as(element, 'literal-punctuation')
        self._reverse_speak_as(element, 'no-punctuation')

        self._isolate_text_node(element)

        self._visit(element, self._speak_as_no_punctuation)","def no_speak(self, element): """"""No speak the punctuation for element and descendants. :param element: The element. :type element: hatemile.util.html.htmldomelement.HTMLDOMElement """""" if element is None: return None if element is None: return None elif element is None: return None elif element is None: return None elif element is None: return None elif element is None: return None elif element is None: return e",SFT
0.6415094339622641,0.5384615384615384,0.6226415094339622,0.49125828776781244,0.49125828776781244,0,3.305183172225952,"def encrypt(receiver_pubhex: str, msg: bytes) -> bytes:
    """"""
    Encrypt with eth public key

    Parameters
    ----------
    receiver_pubhex: str
        Receiver's ethereum public key hex string
    msg: bytes
        Data to encrypt

    Returns
    -------
    bytes
        Encrypted data
    """"""
    disposable_key = generate_key()
    receiver_pubkey = hex2pub(receiver_pubhex)
    aes_key = derive(disposable_key, receiver_pubkey)
    cipher_text = aes_encrypt(aes_key, msg)
    return disposable_key.public_key.format(False) + cipher_text","def encrypt(receiver_pubhex, msg): """"""Encrypt with eth public key Parameters ---------- receiver_pubhex: str Receiver's ethereum public key hex string msg: bytes Data to encrypt Returns ------- bytes Encrypted data """""" if msg is None: msg = msg.encrypt(receiver_pubhex, msg) if",SFT
0.29090909090909095,0.2222222222222222,0.29090909090909095,0.16370594018405277,0.16370594018405277,0,3.0176916122436523,"def get_version():
    """"""Get the version of `package` (by extracting it from the source code).""""""
    module_path = get_absolute_path('pip_save', '__init__.py')
    with open(module_path) as handle:
        for line in handle:
            match = re.match(r'^__version__\s*=\s*[""\']([^""\']+)[""\']$', line)
            if match:
                return match.group(1)
    raise Exception(""Failed to extract version from %s!"" % module_path)","def get_package_version(package): """"""Get the version of package (by extracting it from the source code). """""" if package.is_package(package): if package.is_package(package): if package.is_package(package): if package.is_package(package): if package.is_package(package): if package.is_package(package): if package.is_package(package",SFT
0.7857142857142856,0.7454545454545455,0.7857142857142856,0.539934421954544,0.539934421954544,0,3.548598289489746,"def OE(element, value, transform=lambda x: x):
    """"""
    Create an Optional Element.

    Returns an Element as ElementMaker would, unless value is None. Optionally the value can be
    transformed through a function.

    >>> OE('elem', None)
    None

    >>> lxml.etree.tostring(OE('elem', 'value'))
    <elem>value</elem>

    >>> lxml.etree.tostring(OE('elem', True, int))
    <elem>1</elem>
    """"""
    return E(element, transform(value)) if value is not None else None","def tostring(self, value): """"""Create an Optional Element. Returns an Element as ElementMaker would, unless value is None. Optionally the value can be transformed through a function. >>> OE('elem', None) None >>> lxml.etree.tostring(OE('elem', 'value')) elem>value/elem> >>> lxml.etree.tostring(OE('elem', True",SFT
0.4785276073619632,0.3975155279503106,0.4785276073619632,0.22455313824789613,0.22455313824789613,0,3.382172107696533,"def _wrapped_overflow_add(a, b):
        """"""
        Determines if an overflow happens during the addition of `a` and `b`.

        :param a: The first operand (StridedInterval)
        :param b: The other operand (StridedInterval)
        :return: True if overflows, False otherwise
        """"""

        if a.is_integer and a.lower_bound == 0:
            # Special case: if `a` or `b` is a zero
            card_self = 0
        else:
            card_self = StridedInterval._wrapped_cardinality(a.lower_bound, a.upper_bound, a.bits)

        if b.is_integer and b.lower_bound == 0:
            # Special case: if `a` or `b` is a zero
            card_b = 0
        else:
            card_b = StridedInterval._wrapped_cardinality(b.lower_bound, b.upper_bound, b.bits)

        return (card_self + card_b) > (StridedInterval.max_int(a.bits) + 1)","def overflow(self, a, b): """""" Determines if an overflow happens during the addition of a and b. :param a: The first operand (StridedInterval) :param b: The other operand (StridedInterval) :return: True if overflows, False otherwise """""" if self._overflows: self._overflows = self._overflows if self._overflows: self.",SFT
0.4859813084112149,0.4639498432601881,0.4797507788161994,0.12264143928431888,0.12264143928431888,0,3.464855670928955,"def get_port_def(port_num, proto='tcp'):
    '''
    Given a port number and protocol, returns the port definition expected by
    docker-py. For TCP ports this is simply an integer, for UDP ports this is
    (port_num, 'udp').

    port_num can also be a string in the format 'port_num/udp'. If so, the
    ""proto"" argument will be ignored. The reason we need to be able to pass in
    the protocol separately is because this function is sometimes invoked on
    data derived from a port range (e.g. '2222-2223/udp'). In these cases the
    protocol has already been stripped off and the port range resolved into the
    start and end of the range, and get_port_def() is invoked once for each
    port number in that range. So, rather than munge udp ports back into
    strings before passing them to this function, the function will see if it
    has a string and use the protocol from it if present.

    This function does not catch the TypeError or ValueError which would be
    raised if the port number is non-numeric. This function either needs to be
    run on known good input, or should be run within a try/except that catches
    these two exceptions.
    '''
    try:
        port_num, _, port_num_proto = port_num.partition('/')
    except AttributeError:
        pass
    else:
        if port_num_proto:
            proto = port_num_proto
    try:
        if proto.lower() == 'udp':
            return int(port_num), 'udp'
    except AttributeError:
        pass
    return int(port_num)","def get_port_definition(port_num, protocol): """""" Given a port number and protocol, returns the port definition expected by docker-py. For TCP ports this is simply an integer, for UDP ports this is (port_num, 'udp'). port_num can also be a string in the format 'port_num/udp'. If so, the ""proto"" argument will be ignored. The reason we need to be able to pass in the protocol separately is because this function is sometimes invoked on",SFT
0.7304347826086957,0.6194690265486725,0.6956521739130435,0.33467490331745614,0.33467490331745614,0,3.223278284072876,"def get_kernel_spec(self, kernel_name):
        """"""Returns a :class:`KernelSpec` instance for the given kernel_name.

        Raises :exc:`NoSuchKernel` if the given kernel name is not found.
        """"""
        try:
            return super(EnvironmentKernelSpecManager,
                         self).get_kernel_spec(kernel_name)
        except (NoSuchKernel, FileNotFoundError):
            venv_kernel_name = kernel_name.lower()
            specs = self.get_all_kernel_specs_for_envs()
            if venv_kernel_name in specs:
                return specs[venv_kernel_name]
            else:
                raise NoSuchKernel(kernel_name)","def get_kernel_spec(self, kernel_name): """""" Returns a :class:KernelSpec instance for the given kernel_name. Raises :exc:NoSuchKernel if the given kernel name is not found. """""" if kernel_name is None: kernel_spec = self.get_kernel_spec(kernel_name) return kernel_spec",SFT
0.4927536231884058,0.2686567164179104,0.463768115942029,0.2603580412896648,0.2603580412896648,0,1.7643301486968994,"def harvest_openaire_projects(source=None, setspec=None):
    """"""Harvest grants from OpenAIRE and store as authority records.""""""
    loader = LocalOAIRELoader(source=source) if source \
        else RemoteOAIRELoader(setspec=setspec)
    for grant_json in loader.iter_grants():
        register_grant.delay(grant_json)","def harvest_grants(self): """""" Harvest grants from OpenAIRE and store as authority records. """""" if self.grants is None: self.grants = self.grants self.grants = self.grants self.grants = self.grants",SFT
0.3129251700680272,0.11034482758620691,0.3129251700680272,0.03143999966077308,0.03143999966077308,0,2.557401418685913,"def formatted(self):
    ''' print a nicely formatted output of this report '''

    return """"""
Weather Station: %s (%s, %s)
Elevation: %s m
Time: %s UTC
Air Temperature: %s C (%s F)
Wind Speed: %s m/s (%s mph)
Wind Direction: %s
Present Weather Obs: %s
Precipitation: %s
Cloud Coverage: %s oktas
Cloud Summation: %s
Solar Irradiance: %s 
    """""" % (self.weather_station, self.latitude, self.longitude,
           self.elevation, self.datetime, self.air_temperature,
           self.air_temperature.get_fahrenheit(), self.wind_speed,
           self.wind_speed.get_miles(), self.wind_direction,
           str(self.present_weather), str(self.precipitation),
           str(self.sky_cover), str(self.sky_cover_summation),
           str(self.solar_irradiance))","def print_report(self): """""" print a nicely formatted output of this report """""" if self._report: self._report = self._report if self._report: self._report = self._report if self._report: self._report = self._report if self._report == self._report: self._report = self._report",SFT
0.07519999999999999,0.0689102564102564,0.07519999999999999,1.5627525410087885e-09,1.5627525410087885e-09,0,3.4731414318084717,"def plot_multitrack(multitrack, filename=None, mode='separate',
                    track_label='name', preset='default', cmaps=None,
                    xtick='auto', ytick='octave', xticklabel=True,
                    yticklabel='auto', tick_loc=None, tick_direction='in',
                    label='both', grid='both', grid_linestyle=':',
                    grid_linewidth=.5):
    """"""
    Plot the pianorolls or save a plot of them.

    Parameters
    ----------
    filename : str
        The filename to which the plot is saved. If None, save nothing.
    mode : {'separate', 'stacked', 'hybrid'}
        A string that indicate the plotting mode to use. Defaults to
        'separate'.

        - In 'separate' mode, all the tracks are plotted separately.
        - In 'stacked' mode, a color is assigned based on `cmaps` to the
            pianoroll of each track and the pianorolls are stacked and
            plotted as a colored image with RGB channels.
        - In 'hybrid' mode, the drum tracks are merged into a 'Drums' track,
            while the other tracks are merged into an 'Others' track, and the
            two merged tracks are then plotted separately.

    track_label : {'name', 'program', 'family', 'off'}
        A sting that indicates what to use as labels to the track. When
        `mode` is 'hybrid', all options other than 'off' will label the two
        track with 'Drums' and 'Others'.
    preset : {'default', 'plain', 'frame'}
        A string that indicates the preset theme to use.

        - In 'default' preset, the ticks, grid and labels are on.
        - In 'frame' preset, the ticks and grid are both off.
        - In 'plain' preset, the x- and y-axis are both off.

    cmaps :  tuple or list
        The `matplotlib.colors.Colormap` instances or colormap codes to use.

        - When `mode` is 'separate', each element will be passed to each
            call of :func:`matplotlib.pyplot.imshow`. Defaults to ('Blues',
            'Oranges', 'Greens', 'Reds', 'Purples', 'Greys').
        - When `mode` is stacked, a color is assigned based on `cmaps` to
            the pianoroll of each track. Defaults to ('hsv').
        - When `mode` is 'hybrid', the first (second) element is used in the
            'Drums' ('Others') track. Defaults to ('Blues', 'Greens').

    xtick : {'auto', 'beat', 'step', 'off'}
        A string that indicates what to use as ticks along the x-axis. If
        'auto' is given, automatically set to 'beat' if `beat_resolution` is
        also given and set to 'step', otherwise. Defaults to 'auto'.
    ytick : {'octave', 'pitch', 'off'}
        A string that indicates what to use as ticks along the y-axis.
        Defaults to 'octave'.
    xticklabel : bool
        Whether to add tick labels along the x-axis. Only effective when
        `xtick` is not 'off'.
    yticklabel : {'auto', 'name', 'number', 'off'}
        If 'name', use octave name and pitch name (key name when `is_drum`
        is True) as tick labels along the y-axis. If 'number', use pitch
        number. If 'auto', set to 'name' when `ytick` is 'octave' and
        'number' when `ytick` is 'pitch'. Defaults to 'auto'. Only effective
        when `ytick` is not 'off'.
    tick_loc : tuple or list
        The locations to put the ticks. Availables elements are 'bottom',
        'top', 'left' and 'right'. Defaults to ('bottom', 'left').
    tick_direction : {'in', 'out', 'inout'}
        A string that indicates where to put the ticks. Defaults to 'in'.
        Only effective when one of `xtick` and `ytick` is on.
    label : {'x', 'y', 'both', 'off'}
        A string that indicates whether to add labels to the x-axis and
        y-axis. Defaults to 'both'.
    grid : {'x', 'y', 'both', 'off'}
        A string that indicates whether to add grids to the x-axis, y-axis,
        both or neither. Defaults to 'both'.
    grid_linestyle : str
        Will be passed to :meth:`matplotlib.axes.Axes.grid` as 'linestyle'
        argument.
    grid_linewidth : float
        Will be passed to :meth:`matplotlib.axes.Axes.grid` as 'linewidth'
        argument.

    Returns
    -------
    fig : `matplotlib.figure.Figure` object
        A :class:`matplotlib.figure.Figure` object.
    axs : list
        List of :class:`matplotlib.axes.Axes` object.

    """"""
    if not HAS_MATPLOTLIB:
        raise ImportError(""matplotlib package is required for plotting ""
                          ""supports."")

    def get_track_label(track_label, track=None):
        """"""Convenient function to get track labels""""""
        if track_label == 'name':
            return track.name
        elif track_label == 'program':
            return pretty_midi.program_to_instrument_name(track.program)
        elif track_label == 'family':
            return pretty_midi.program_to_instrument_class(track.program)
        elif track is None:
            return track_label

    def add_tracklabel(ax, track_label, track=None):
        """"""Convenient function for adding track labels""""""
        if not ax.get_ylabel():
            return
        ax.set_ylabel(get_track_label(track_label, track) + '\n\n'
                      + ax.get_ylabel())

    multitrack.check_validity()
    if not multitrack.tracks:
        raise ValueError(""There is no track to plot."")
    if mode not in ('separate', 'stacked', 'hybrid'):
        raise ValueError(""`mode` must be one of {'separate', 'stacked', ""
                         ""'hybrid'}."")
    if track_label not in ('name', 'program', 'family', 'off'):
        raise ValueError(""`track_label` must be one of {'name', 'program', ""
                         ""'family'}."")

    if cmaps is None:
        if mode == 'separate':
            cmaps = ('Blues', 'Oranges', 'Greens', 'Reds', 'Purples', 'Greys')
        elif mode == 'stacked':
            cmaps = ('hsv')
        else:
            cmaps = ('Blues', 'Greens')

    num_track = len(multitrack.tracks)
    downbeats = multitrack.get_downbeat_steps()

    if mode == 'separate':
        if num_track > 1:
            fig, axs = plt.subplots(num_track, sharex=True)
        else:
            fig, ax = plt.subplots()
            axs = [ax]

        for idx, track in enumerate(multitrack.tracks):
            now_xticklabel = xticklabel if idx < num_track else False
            plot_pianoroll(axs[idx], track.pianoroll, False,
                           multitrack.beat_resolution, downbeats, preset=preset,
                           cmap=cmaps[idx%len(cmaps)], xtick=xtick, ytick=ytick,
                           xticklabel=now_xticklabel, yticklabel=yticklabel,
                           tick_loc=tick_loc, tick_direction=tick_direction,
                           label=label, grid=grid,
                           grid_linestyle=grid_linestyle,
                           grid_linewidth=grid_linewidth)
            if track_label != 'none':
                add_tracklabel(axs[idx], track_label, track)

        if num_track > 1:
            fig.subplots_adjust(hspace=0)

        if filename is not None:
            plt.savefig(filename)

        return (fig, axs)

    elif mode == 'stacked':
        is_all_drum = True
        for track in multitrack.tracks:
            if not track.is_drum:
                is_all_drum = False

        fig, ax = plt.subplots()
        stacked = multitrack.get_stacked_pianorolls()

        colormap = matplotlib.cm.get_cmap(cmaps[0])
        cmatrix = colormap(np.arange(0, 1, 1 / num_track))[:, :3]
        recolored = np.matmul(stacked.reshape(-1, num_track), cmatrix)
        stacked = recolored.reshape(stacked.shape[:2] + (3, ))

        plot_pianoroll(ax, stacked, is_all_drum, multitrack.beat_resolution,
                       downbeats, preset=preset, xtick=xtick, ytick=ytick,
                       xticklabel=xticklabel, yticklabel=yticklabel,
                       tick_loc=tick_loc, tick_direction=tick_direction,
                       label=label, grid=grid, grid_linestyle=grid_linestyle,
                       grid_linewidth=grid_linewidth)

        if track_label != 'none':
            patches = [Patch(color=cmatrix[idx],
                             label=get_track_label(track_label, track))
                       for idx, track in enumerate(multitrack.tracks)]
            plt.legend(handles=patches)

        if filename is not None:
            plt.savefig(filename)

        return (fig, [ax])

    elif mode == 'hybrid':
        drums = [i for i, track in enumerate(multitrack.tracks)
                 if track.is_drum]
        others = [i for i in range(len(multitrack.tracks)) if i not in drums]
        merged_drums = multitrack.get_merged_pianoroll(drums)
        merged_others = multitrack.get_merged_pianoroll(others)

        fig, (ax1, ax2) = plt.subplots(2, sharex=True, sharey=True)
        plot_pianoroll(ax1, merged_drums, True, multitrack.beat_resolution,
                       downbeats, preset=preset, cmap=cmaps[0], xtick=xtick,
                       ytick=ytick, xticklabel=xticklabel,
                       yticklabel=yticklabel, tick_loc=tick_loc,
                       tick_direction=tick_direction, label=label, grid=grid,
                       grid_linestyle=grid_linestyle,
                       grid_linewidth=grid_linewidth)
        plot_pianoroll(ax2, merged_others, False, multitrack.beat_resolution,
                       downbeats, preset=preset, cmap=cmaps[1], ytick=ytick,
                       xticklabel=xticklabel, yticklabel=yticklabel,
                       tick_loc=tick_loc, tick_direction=tick_direction,
                       label=label, grid=grid, grid_linestyle=grid_linestyle,
                       grid_linewidth=grid_linewidth)
        fig.subplots_adjust(hspace=0)

        if track_label != 'none':
            add_tracklabel(ax1, 'Drums')
            add_tracklabel(ax2, 'Others')

        if filename is not None:
            plt.savefig(filename)

        return (fig, [ax1, ax2])","def plot(self, filename, mode='separate', **kwargs): """"""Plot the pianorolls or save a plot of them. Parameters ---------- filename : str The filename to which the plot is saved. If None, save nothing. mode : 'separate', 'stacked', 'hybrid' A string that indicate the plotting mode to use. Defaults to 'separate'. - In 'separ",SFT
0.32558139534883723,0.16666666666666669,0.32558139534883723,0.07751250612884825,0.07751250612884825,0,1.8128306865692139,"def get_friends(self):
        """"""Get user's friends.""""""
        for k, v in iter(self.user_data.language_data.items()):
            data = []
            for friend in v['points_ranking_data']:
                temp = {'username': friend['username'],
                        'id': friend['id'],
                        'points': friend['points_data']['total'],
                        'languages': [i['language_string'] for i in
                                      friend['points_data']['languages']]}
                data.append(temp)

            return data","def get_friends(self): """"""Get user's friends."""""" if self._friends is None: self._friends = self._friends if self._friends is None: self._friends = self._friends else: self._friends = self._friends",SFT
0.3297297297297297,0.2934782608695652,0.30810810810810807,0.035686815606251816,0.035686815606251816,0,3.468559503555298,"def aa_db_search(self, files, base, unpack, search_method,
                     maximum_range, threads, evalue, min_orf_length,
                     restrict_read_length, diamond_database):
        '''
        Amino acid database search pipeline - pipeline where reads are searched
        as amino acids, and hits are identified using hmmsearch or diamond
        searches

        Parameters
        ----------
        files : obj
            graftm_output_paths object.
        base : str
            The name of the input file, stripped of all suffixes, and paths.
            Used for creating file names with 'files' object.
        unpack : obj
            UnpackRawReads object, returns string command that will output
            sequences to stdout when called on command line
            (use: unpack.command_line())
        search_method : str
            The method for searching, either 'hmmsearch' or 'diamond'
        maximum_range : int
            Maximum range that a gene can extend within a contig. Any hits
            that extend beyond this length cannot be linked. max_range is defined
            as 1.5 X the average length of all full length genes used in the
            search database. This is defined in the CONTENTS.json file within a
            gpkg.
        threads : int
            Number of threads for hmmer to use
        evalue : str
            evalue cutoff for hmmer to use
        min_orf_length : int
            minimum orf length for orfm to use
        restrict_read_length : int
            orf length to retrict orfm to.
        diamond_database : str
            Path to diamond database to use when searching. Set to 'None' if not
            using diamond pipeline
        Returns
        -------
        String path to amino acid fasta file of reads that hit
        '''
        # Define outputs
        if search_method == 'hmmsearch':
            output_search_file = files.hmmsearch_output_path(base)
        elif search_method == 'diamond':
            output_search_file = files.diamond_search_output_basename(base)
        hit_reads_fasta = files.fa_output_path(base)
        hit_reads_orfs_fasta = files.orf_fasta_output_path(base)

        return self.search_and_extract_orfs_matching_protein_database(\
                                                    unpack,
                                                    search_method,
                                                    maximum_range,
                                                    threads,
                                                    evalue,
                                                    min_orf_length,
                                                    restrict_read_length,
                                                    diamond_database,
                                                    output_search_file,
                                                    hit_reads_fasta,
                                                    hit_reads_orfs_fasta)","def amino_acid_search_pipeline(files, base, unpack=None): """""" Amino acid database search pipeline - pipeline where reads are searched as amino acids, and hits are identified using hmmsearch or diamond searches Parameters ---------- files : obj graftm_output_paths object. base : str The name of the input file, stripped of all suffixes, and paths. Used for creating file names with 'files' object. unpack :",SFT
0.7352941176470588,0.606060606060606,0.7058823529411765,0.5829920268083592,0.5829920268083592,0,2.317368745803833,"def load_dict_from_yaml(path):
    """"""
    Loads a dictionary from a yaml file
    :param path: the absolute path of the target yaml file
    :return:
    """"""
    f = file(path, 'r')
    dictionary = yaml.load(f)
    f.close()
    return dictionary","def _load_dict(self, path): """""" Loads a dictionary from a yaml file :param path: the absolute path of the target yaml file :return: """""" if path is None: return self._load_dict(path)",SFT
0.5806451612903226,0.522875816993464,0.5419354838709677,0.06860891965622924,0.06860891965622924,0,3.407566785812378,"def commit_cancelled(name):
    '''
    .. versionadded:: 2019.2.0

    Cancel a commit scheduled to be executed via the ``commit_in`` and
    ``commit_at`` arguments from the
    :py:func:`net.load_template <salt.modules.napalm_network.load_template>` or
    :py:func:`net.load_config <salt.modules.napalm_network.load_config>`
    execution functions. The commit ID is displayed when the commit is scheduled
    via the functions named above.

    State SLS Example:

    .. code-block:: yaml

        '20180726083540640360':
          netconfig.commit_cancelled
    '''
    cancelled = {
        'name': name,
        'result': None,
        'changes': {},
        'comment': ''
    }
    if __opts__['test']:
        cancelled['comment'] = 'It would cancel commit #{}'.format(name)
        return cancelled
    ret = __salt__['net.cancel_commit'](name)
    cancelled.update(ret)
    return cancelled","def cancel_commit(self, commit_in, commit_at): ''' .. versionadded:: 2019.2.0 Cancel a commit scheduled to be executed via the commit_in and commit_at arguments from the :py:func:net.load_template salt.modules.napalm_network.load_template> or :py:func:net.load_config salt.modules.napal",SFT
0.7863247863247863,0.782608695652174,0.7863247863247863,0.43889499848200164,0.43889499848200164,0,3.507636547088623,"def get_objective_objective_bank_session(self):
        """"""Gets the session for retrieving objective to objective bank mappings.

        return: (osid.learning.ObjectiveObjectiveBankSession) - an
                ``ObjectiveObjectiveBankSession``
        raise:  OperationFailed - unable to complete request
        raise:  Unimplemented - ``supports_objective_objective_bank()``
                is ``false``
        *compliance: optional -- This method must be implemented if
        ``supports_objective_objective_bank()`` is ``true``.*

        """"""
        if not self.supports_objective_objective_bank():
            raise errors.Unimplemented()
        # pylint: disable=no-member
        return sessions.ObjectiveObjectiveBankSession(runtime=self._runtime)","def get_objective_objective_bank_session(self): """"""Gets the session for retrieving objective to objective bank mappings. return: (osid.learning.ObjectiveObjectiveBankSession) - an ObjectiveObjectiveBankSession raise: OperationFailed - unable to complete request raise: Unimplemented - supports_objective_objective_bank() is false *compliance: optional -- This method must be implemented if support",SFT
0.3846153846153846,0.24,0.3846153846153846,0.2715490038158442,0.2715490038158442,0,1.591015338897705,"def split_timesteps(data, consistent_abmn=False):
    """"""Split data into multiple timesteps.""""""
    if has_multiple_timesteps(data):
        grouped = data.groupby(""timestep"")
        return [group[1] for group in grouped]
    else:
        return data","def split_timesteps(self): """"""Split data into multiple timesteps."""""" self.split_timesteps() self.split_timesteps() self.split_timesteps() self.split_timesteps()",SFT
0.24,0.12903225806451613,0.224,0.002305440756005559,0.002305440756005559,0,2.7662172317504883,"def find_your_legislator(request):
    '''
    Context:
        - request
        - lat
        - long
        - located
        - legislators

    Templates:
        - billy/web/public/find_your_legislator_table.html
    '''

    # check if lat/lon are set
    # if leg_search is set, they most likely don't have ECMAScript enabled.
    # XXX: fallback behavior here for alpha.

    get = request.GET
    context = {}
    template = 'find_your_legislator'

    context['request'] = """"
    if ""q"" in get:
        context['request'] = get['q']

    if ""lat"" in get and ""lon"" in get:
        # We've got a passed lat/lon. Let's build off it.
        lat = get['lat']
        lon = get['lon']

        context['lat'] = lat
        context['lon'] = lon
        context['located'] = True

        qurl = ""%slegislators/geo/?long=%s&lat=%s&apikey=%s"" % (
            billy_settings.API_BASE_URL,
            lon,
            lat,
            getattr(billy_settings, 'API_KEY', '')
        )
        leg_resp = json.load(urllib2.urlopen(qurl, timeout=0.5))
        # allow limiting lookup to region for region map views
        if 'abbr' in get:
            leg_resp = [leg for leg in leg_resp
                        if leg[billy_settings.LEVEL_FIELD] == get['abbr']]
            context['abbr'] = get['abbr']

        # Also, allow filtering by chamber
        if 'chamber' in get:
            leg_resp = [leg for leg in leg_resp
                        if leg['chamber'] == get['chamber']]
            context['chamber'] = get['chamber']

        if ""boundary"" in get:
            return HttpResponse(json.dumps([]))

        context['legislators'] = map(Legislator, leg_resp)
        template = 'find_your_legislator_table'

    return render(request, templatename(template), context)","def find_legislator_table(self, request, lat, long, located): """"""Context: - request - lat - long - located - legislators Templates: - billy/web/public/find_your_legislator_table.html """""" if not isinstance(request, lat, long, located): return self.find_legislator_table(request)",SFT
0.4444444444444444,0.26229508196721313,0.4444444444444444,0.39563636147133036,0.39563636147133036,0,1.6893234252929688,"def get_flagged_names():
    """"""Return a list of all filenames marked as flagged.""""""

    l = []
    for w in _widget_cache.values():
        if w.flagged:
            l.append(w.get_node().get_value())
    return l","def flagged_filenames(self): """"""Return a list of all filenames marked as flagged."""""" if not self.flagged: return False if self.flagged: return False if self.flagged: return False return False",SFT
0.6666666666666666,0.6407766990291263,0.6666666666666666,0.5447699730356873,0.5447699730356873,0,3.507591485977173,"def rightsibling(node):
    """"""
    Return Right Sibling of `node`.

    >>> from anytree import Node
    >>> dan = Node(""Dan"")
    >>> jet = Node(""Jet"", parent=dan)
    >>> jan = Node(""Jan"", parent=dan)
    >>> joe = Node(""Joe"", parent=dan)
    >>> rightsibling(dan)
    >>> rightsibling(jet)
    Node('/Dan/Jan')
    >>> rightsibling(jan)
    Node('/Dan/Joe')
    >>> rightsibling(joe)
    """"""
    if node.parent:
        pchildren = node.parent.children
        idx = pchildren.index(node)
        try:
            return pchildren[idx + 1]
        except IndexError:
            return None
    else:
        return None","def right_sibling(self): """"""Return Right Sibling of node. >>> from anytree import Node >>> dan = Node(""Dan"") >>> jet = Node(""Jet"", parent=dan) >>> jan = Node(""Jan"", parent=dan) >>> joe = Node(""Joe"", parent=dan) >>> rightsibling(dan) >>> rightsibling(jet) Node('/Dan/Jan') >>>",SFT
0.5526315789473684,0.3243243243243243,0.5526315789473684,0.3964092485695982,0.3964092485695982,0,2.0491342544555664,"def _unassigned_ports():
    """""" Returns a set of all unassigned ports (according to IANA and Wikipedia) """"""
    free_ports = ranges_to_set(_parse_ranges(_iana_unassigned_port_ranges()))
    known_ports = ranges_to_set(_wikipedia_known_port_ranges())
    return free_ports.difference(known_ports)","def get_unassigned_ports(self): """"""Returns a set of all unassigned ports (according to IANA and Wikipedia)"""""" if self._ports is None: self._ports = self._ports if self._ports is None: self._ports = self._ports",SFT
0.2564102564102564,0.10526315789473685,0.2564102564102564,0.2760692748225119,0.2760692748225119,0,2.340897560119629,"def plot_groups_unplaced(self, fout_dir=""."", **kws_usr):
        """"""Plot each GO group.""""""
        # kws: go2color max_gos upper_trigger max_upper
        plotobj = PltGroupedGos(self)
        return plotobj.plot_groups_unplaced(fout_dir, **kws_usr)","def plot_go_groups(self): """"""Plot each GO group."""""" if self.go_groups is None: self.go_groups = self.go_groups self.go_groups = self.go_groups self.go_groups = self.go_groups self.go_groups = self.go_groups self.go_groups = self.go_groups",SFT
0.7213114754098361,0.5833333333333334,0.6885245901639344,0.45246107227568955,0.45246107227568955,0,3.3000950813293457,"def checkPassword(self, password):
        """"""
        Check the given plaintext password against the response in this
        credentials object.

        @type password: C{str}
        @param password: The known correct password associated with
            C{self.username}.

        @return: A C{bool}, C{True} if this credentials object agrees with the
            given password, C{False} otherwise.
        """"""
        if isinstance(password, unicode):
            password = password.encode('utf-8')
        correctResponse = _calcResponse(self.challenge, self.nonce, password)
        return correctResponse == self.response","def _check_password(self, password): """""" Check the given plaintext password against the response in this credentials object. @type password: Cstr @param password: The known correct password associated with Cself.username. @return: A Cbool, CTrue if this credentials object agrees with the given password, CFalse otherwise. """""" if not isinstance(password): return False return False",SFT
0.5679012345679012,0.379746835443038,0.5679012345679012,0.3590319438655285,0.3590319438655285,0,3.240823745727539,"def fetch(self):
        """"""
        Fetch a NumberInstance

        :returns: Fetched NumberInstance
        :rtype: twilio.rest.pricing.v1.voice.number.NumberInstance
        """"""
        params = values.of({})

        payload = self._version.fetch(
            'GET',
            self._uri,
            params=params,
        )

        return NumberInstance(self._version, payload, number=self._solution['number'], )","def fetch_number_instance(self): """""" Fetch a NumberInstance :returns: Fetched NumberInstance :rtype: twilio.rest.pricing.v1.voice.number.NumberInstance """""" if self._number_instance is None: self._number_instance = self._number_instance if self._number_instance is None: self._number_instance = self._number_instance",SFT
0.3404255319148936,0.3285714285714286,0.3404255319148936,0.0206202164992579,0.0206202164992579,0,3.4914357662200928,"def iterable(self, iterable_name, *, collection, attribute, word, func=None,
                 operation=None):
        """""" Performs a filter with the OData 'iterable_name' keyword
        on the collection

        For example:
        q.iterable('any', collection='email_addresses', attribute='address',
        operation='eq', word='george@best.com')

        will transform to a filter such as:
        emailAddresses/any(a:a/address eq 'george@best.com')

        :param str iterable_name: the OData name of the iterable
        :param str collection: the collection to apply the any keyword on
        :param str attribute: the attribute of the collection to check
        :param str word: the word to check
        :param str func: the logical function to apply to the attribute inside
         the collection
        :param str operation: the logical operation to apply to the attribute
         inside the collection
        :rtype: Query
        """"""

        if func is None and operation is None:
            raise ValueError('Provide a function or an operation to apply')
        elif func is not None and operation is not None:
            raise ValueError(
                'Provide either a function or an operation but not both')

        current_att = self._attribute
        self._attribute = iterable_name

        word = self._parse_filter_word(word)
        collection = self._get_mapping(collection)
        attribute = self._get_mapping(attribute)

        if func is not None:
            sentence = self._prepare_function(func, attribute, word)
        else:
            sentence = self._prepare_sentence(attribute, operation, word)

        filter_str, attrs = sentence

        filter_data = '{}/{}(a:a/{})'.format(collection, iterable_name, filter_str), attrs
        self._add_filter(*filter_data)

        self._attribute = current_att

        return self","def iterable(self, iterable_name): """""" Performs a filter with the OData 'iterable_name' keyword on the collection For example: q.iterable('any', collection='email_addresses', attribute='address', operation='eq', word='george@best.com') will transform to a filter such as: emailAddresses/any(a:a/address eq 'george@best",SFT
0.16580310880829016,0.13612565445026178,0.16580310880829016,0.003989415728254368,0.003989415728254368,0,3.0133297443389893,"def copy_any(src, dst, only_missing=False):  # pragma: no cover
    """"""Copy a file or a directory tree, deleting the destination before processing""""""
    if not only_missing:
        remove_if_exist(dst)
    if os.path.exists(src):
        if os.path.isdir(src):
            if not only_missing:
                shutil.copytree(src, dst, symlinks=False, ignore=None)
            else:
                for dirpath, filepath in recwalk(src):
                    srcfile = os.path.join(dirpath, filepath)
                    relpath = os.path.relpath(srcfile, src)
                    dstfile = os.path.join(dst, relpath)
                    if not os.path.exists(dstfile):
                        create_dir_if_not_exist(os.path.dirname(dstfile))
                        shutil.copyfile(srcfile, dstfile)
                        shutil.copystat(srcfile, dstfile)
            return True
        elif os.path.isfile(src) and (not only_missing or not os.path.exists(dst)):
            shutil.copyfile(src, dst)
            shutil.copystat(src, dst)
            return True
    return False","def _copy_file(self): """""" Copy a file or a directory tree, deleting the destination before processing """""" if self.dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_",SFT
0.40178571428571436,0.36036036036036034,0.38392857142857145,0.039307367231514526,0.039307367231514526,0,3.337092638015747,"def build_matlab(static=False):
    """"""build the messenger mex for MATLAB

    static : bool
        Determines if the zmq library has been statically linked.
        If so, it will append the command line option -DZMQ_STATIC
        when compiling the mex so it matches libzmq.
    """"""
    cfg = get_config()
    # To deal with spaces, remove quotes now, and add
    # to the full commands themselves.
    if 'matlab_bin' in cfg and cfg['matlab_bin'] != '.':
        matlab_bin = cfg['matlab_bin'].strip('""')
    else:  # attempt to autodetect MATLAB filepath
        matlab_bin = which_matlab()
        if matlab_bin is None:
            raise ValueError(""specify 'matlab_bin' in cfg file"")
    # Get the extension
    extcmd = esc(os.path.join(matlab_bin, ""mexext""))
    extension = subprocess.check_output(extcmd, shell=use_shell)
    extension = extension.decode('utf-8').rstrip('\r\n')

    # Build the mex file
    mex = esc(os.path.join(matlab_bin, ""mex""))
    paths = ""-L%(zmq_lib)s -I%(zmq_inc)s"" % cfg
    make_cmd = '%s -O %s -lzmq ./src/messenger.c' % (mex, paths)
    if static:
        make_cmd += ' -DZMQ_STATIC'
    do_build(make_cmd, 'messenger.%s' % extension)","def build_message_mex(self, static=False): """""" build the messenger mex for MATLAB static : bool Determines if the zmq library has been statically linked. If so, it will append the command line option -DZMQ_STATIC when compiling the mex so it matches libzmq. """""" if static is None: self._message_message_message = self._message_message_mes",SFT
0.2831858407079646,0.23423423423423423,0.2831858407079646,0.11054062842504174,0.11054062842504174,0,3.016308307647705,"def timetopythonvalue(time_val):
    ""Convert a time or time range from ArcGIS REST server format to Python""
    if isinstance(time_val, sequence):
        return map(timetopythonvalue, time_val)
    elif isinstance(time_val, numeric):
        return datetime.datetime(*(time.gmtime(time_val))[:6])
    elif isinstance(time_val, numeric):
        values = []
        try:
            values = map(long, time_val.split("",""))
        except:
            pass
        if values:
            return map(timetopythonvalue, values)
    raise ValueError(repr(time_val))","def _convert_to_python(self): """"""Convert a time or time range from ArcGIS REST server format to Python"""""" if self._timestamp is None: self._timestamp = self._timestamp if self._timestamp is None: self._timestamp = self._timestamp if self._timestamp is None: self._timestamp = self._timestamp if self.",SFT
0.75,0.6455696202531646,0.7125,0.5313173346155385,0.5313173346155385,0,3.331063985824585,"def emit(self, name=None, data=None):
        """"""
        Emit an event annotated with the UTC time when this function was called.

        `name` is a unique identification string for an event that has
            already been registered.
        `data` is a dictionary mapping field names to the value to include in the event.
            Note that all values provided must be serializable.

        """"""
        event = {
            'name': name or UNKNOWN_EVENT_TYPE,
            'timestamp': datetime.now(UTC),
            'data': data or {},
            'context': self.resolve_context()
        }

        self.routing_backend.send(event)","def _emit_event(self, name, data): """"""Emit an event annotated with the UTC time when this function was called. name is a unique identification string for an event that has already been registered. data is a dictionary mapping field names to the value to include in the event. Note that all values provided must be serializable. """""" if data is None: if data is None: if data is None: if data is None: if data is None: if data is None",SFT
0.5528455284552846,0.46280991735537186,0.5528455284552846,0.2963137246641847,0.2963137246641847,0,2.443126916885376,"def resolution_order(lang, override=None):
    """"""
    Return order of languages which should be checked for parameter language.
    First is always the parameter language, later are fallback languages.
    Override parameter has priority over FALLBACK_LANGUAGES.
    """"""
    if not settings.ENABLE_FALLBACKS:
        return (lang,)
    if override is None:
        override = {}
    fallback_for_lang = override.get(lang, settings.FALLBACK_LANGUAGES.get(lang, ()))
    fallback_def = override.get('default', settings.FALLBACK_LANGUAGES['default'])
    order = (lang,) + fallback_for_lang + fallback_def
    return tuple(unique(order))","def _check_languages(self): """"""Return order of languages which should be checked for parameter language. First is always the parameter language, later are fallback languages. Override parameter has priority over FALLBACK_LANGUAGES. """""" if self._languages: return self._languages[self._languages] else: return self._languages[self._languages]",SFT
0.660377358490566,0.576923076923077,0.660377358490566,0.3308644883603748,0.3308644883603748,0,3.2295825481414795,"def count(self, model_class, conditions=None):
        '''
        Counts the number of records in the model's table.

        - `model_class`: the model to count.
        - `conditions`: optional SQL conditions (contents of the WHERE clause).
        '''
        query = 'SELECT count() FROM $table'
        if conditions:
            query += ' WHERE ' + conditions
        query = self._substitute(query, model_class)
        r = self._send(query)
        return int(r.text) if r.text else 0","def count_records(self, model_class, conditions=None): """"""Counts the number of records in the model's table. - model_class: the model to count. - conditions: optional SQL conditions (contents of the WHERE clause). """""" self._count_records = self._count_records self._count_records = self._count_records",SFT
0.7391304347826085,0.5909090909090909,0.7391304347826085,0.5078638261695079,0.5078638261695079,0,1.9075279235839844,"def update(self, **kwargs):
        """"""Update fields

        :param KeywordArguments kwargs: Fields and values to update.
        """"""
        for kw in kwargs:
            setattr(self, kw, kwargs[kw])","def update_fields(self, kwargs): """""" Update fields :param KeywordArguments kwargs: Fields and values to update. """""" self._update_fields(kwargs) self._update_fields(kwargs)",SFT
0.3692307692307692,0.2222222222222222,0.3692307692307692,0.22553917613063712,0.22553917613063712,0,1.9596195220947266,"def map_legacy_frequencies(form, field):
    ''' Map legacy frequencies to new ones'''
    if field.data in LEGACY_FREQUENCIES:
        field.data = LEGACY_FREQUENCIES[field.data]","def _map_old_frequency(self): """"""Map legacy frequencies to new ones"""""" if self._map_old_frequency is None: self._map_old_frequency = self._map_old_frequency if self._map_old_frequency is None: self._map_old_frequency = self._map_old_frequency",SFT
0.75,0.588235294117647,0.7115384615384615,0.47393334038364254,0.47393334038364254,0,2.1533777713775635,"def dependents_of(self, address):
    """"""Returns the addresses of the targets that depend on the target at `address`.

    This method asserts that the address given is actually in the BuildGraph.

    :API: public
    """"""
    assert address in self._target_by_address, (
      'Cannot retrieve dependents of {address} because it is not in the BuildGraph.'
      .format(address=address)
    )
    return self._target_dependees_by_address[address]","def get_target_address(self, address): """""" Returns the addresses of the targets that depend on the target at address. This method asserts that the address given is actually in the BuildGraph. :API: public """""" if address is None: return self.get_target_address(address)",SFT
0.25000000000000006,0.22393822393822396,0.2269230769230769,0.0013400357591424647,0.0013400357591424647,0,3.4037554264068604,"def assign_edge_colors_and_widths(self):
        """"""
        Resolve conflict of 'node_color' and 'node_style['fill'] args which are
        redundant. Default is node_style.fill unless user entered node_color.
        To enter multiple colors user must use node_color not style fill. 
        Either way, we build a list of colors to pass to Drawing.node_colors 
        which is then written to the marker as a fill CSS attribute.
        """"""
        # node_color overrides fill. Tricky to catch cuz it can be many types.

        # SET edge_widths and POP edge_style.stroke-width
        if self.style.edge_widths is None:
            if not self.style.edge_style[""stroke-width""]:
                self.style.edge_style.pop(""stroke-width"")
                self.style.edge_style.pop(""stroke"")
                self.edge_widths = [None] * self.nedges
            else:
                if isinstance(self.style.edge_style[""stroke-width""], (list, tuple)):
                    raise ToytreeError(
                        ""Use edge_widths not edge_style for multiple edge widths"")
                # check the color
                width = self.style.edge_style[""stroke-width""]
                self.style.edge_style.pop(""stroke-width"")
                self.edge_widths = [width] * self.nedges
        else:
            self.style.edge_style.pop(""stroke-width"")            
            if isinstance(self.style.edge_widths, (str, int)):
                self.edge_widths = [int(self.style.edge_widths)] * self.nedges

            elif isinstance(self.style.edge_widths, (list, tuple)):
                if len(self.style.edge_widths) != self.nedges:
                    raise ToytreeError(""edge_widths arg is the wrong length"")
                for cidx in range(self.nedges):
                    self.edge_widths[cidx] = self.style.edge_widths[cidx]

        # SET edge_colors and POP edge_style.stroke
        if self.style.edge_colors is None:
            if self.style.edge_style[""stroke""] is None:
                self.style.edge_style.pop(""stroke"")
                self.edge_colors = [None] * self.nedges
            else:
                if isinstance(self.style.edge_style[""stroke""], (list, tuple)):
                    raise ToytreeError(
                        ""Use edge_colors not edge_style for multiple edge colors"")
                # check the color
                color = self.style.edge_style[""stroke""]
                if isinstance(color, (np.ndarray, np.void, list, tuple)):
                    color = toyplot.color.to_css(color)
                self.style.edge_style.pop(""stroke"")                    
                self.edge_colors = [color] * self.nedges

        # otherwise parse node_color
        else:
            self.style.edge_style.pop(""stroke"")                                
            if isinstance(self.style.edge_colors, (str, int)):
                # check the color
                color = self.style.edge_colors
                if isinstance(color, (np.ndarray, np.void, list, tuple)):
                    color = toyplot.color.to_css(color)
                self.edge_colors = [color] * self.nedges

            elif isinstance(self.style.edge_colors, (list, tuple)):
                if len(self.style.edge_colors) != self.nedges:
                    raise ToytreeError(""edge_colors arg is the wrong length"")
                for cidx in range(self.nedges):
                    self.edge_colors[cidx] = self.style.edge_colors[cidx]

        # do not allow empty edge_colors or widths
        self.edge_colors = [i if i else ""#262626"" for i in self.edge_colors]
        self.edge_widths = [i if i else 2 for i in self.edge_widths]","def resolve_conflict(self, node_color=None, node_style=None): """"""Resolve conflict of 'node_color' and 'node_style['fill'] args which are redundant. Default is node_style.fill unless user entered node_color. To enter multiple colors user must use node_color not style fill. Either way, we build a list of colors to pass to Drawing.node_colors which is then written to the marker as",SFT
0.36363636363636365,0.16494845360824742,0.3434343434343434,0.20203917175414324,0.20203917175414324,0,2.9927804470062256,"def add_filter(self, filter_):
        """""" Add an image filter for post-processing """"""
        assert has_pil, _(""Cannot add filters without python PIL"")
        self.cache.basename += filter_.basename
        self._filters.append(filter_)","def add_image_filter(self): """"""Add an image filter for post-processing"""""" if self.image_filter is None: self.image_filter = self.image_filter if self.image_filter is None: self.image_filter = self.image_filter if self.image_filter is None: self.image_filter = self.image_filter if self.image_filter is None: self.image_filter = self.image_filter if self.image_filter: self.image_filter = self.image",SFT
0.6153846153846153,0.39999999999999997,0.6153846153846153,0.25203116506582973,0.25203116506582973,0,1.3712234497070312,"def _to_dict(self):
        """"""Return a json dictionary representing this model.""""""
        _dict = {}
        if hasattr(self, 'environments') and self.environments is not None:
            _dict['environments'] = [x._to_dict() for x in self.environments]
        return _dict","def get_dict(self): """"""Return a json dictionary representing this model."""""" dict = self.get_dict(dict) return dict",SFT
0.3829787234042554,0.28260869565217395,0.3404255319148936,0.18444220102349232,0.18444220102349232,0,3.004300117492676,"def delete_issue_link_type(self, issue_link_type_id):
        """"""Delete the specified issue link type.""""""
        url = 'rest/api/2/issueLinkType/{issueLinkTypeId}'.format(issueLinkTypeId=issue_link_type_id)
        return self.delete(url)","def delete(self, issue_link_type): """"""Delete the specified issue link type."""""" if not isinstance(issue_link_type): raise ValueError(""The issue link type is not specified"") if isinstance(issue_link_type): raise ValueError(""The issue link type is not specified"") if isinstance(issue_link_type): raise ValueError(""The issue link type is not specified"") if isinstance(issue_link_type): raise ValueErr",SFT
0.6027397260273972,0.3661971830985915,0.5753424657534246,0.2889714597287037,0.2889714597287037,0,2.313704490661621,"def _with_columns(self, columns):
        """"""Create a table from a sequence of columns, copying column labels.""""""
        table = type(self)()
        for label, column in zip(self.labels, columns):
            self._add_column_and_format(table, label, column)
        return table","def from_columns(self): """""" Create a table from a sequence of columns, copying column labels. """""" if self.columns is None: self.columns = self.columns self.columns = self.columns self.columns = self.columns self.columns = self.columns",SFT
0.6192893401015229,0.5846153846153846,0.6091370558375635,0.26185174313949955,0.26185174313949955,0,3.353926420211792,"def Validate(self, value):
    """"""Validate the value.

    Args:
      value: Value is expected to be a dict-like object that a given RDFStruct
        can be initialized from.

    Raises:
      TypeValueError: If the value is not a valid dict-like object that a given
        RDFStruct can be initialized from.

    Returns:
      A valid instance of self.rdfclass or None.
    """"""
    if value is None:
      return None

    if not isinstance(value, self.rdfclass):
      # Try to coerce the type to the correct rdf_class.
      try:
        r = self.rdfclass()
        r.FromDict(value)
        return r
      except (AttributeError, TypeError, rdfvalue.InitializeError):
        # AttributeError is raised if value contains items that don't
        # belong to the given rdfstruct.
        # TypeError will be raised if value is not a dict-like object.
        raise TypeValueError(""Value for arg %s should be an %s"" %
                             (self.name, self.rdfclass.__name__))

    return value","def validate(self, value): """"""Validate the value. Args: value: Value is expected to be a dict-like object that a given RDFStruct can be initialized from. Raises: TypeValueError: If the value is not a valid dict-like object that a given RDFStruct can be initialized from. Returns: A valid instance of self.rdfclass or None. """""" if self.rdfclass is None: raise TypeValue",SFT
0.6046511627906976,0.47619047619047616,0.6046511627906976,0.426208262606818,0.426208262606818,0,3.0429515838623047,"def assert_valid_schema(schema: GraphQLSchema) -> None:
    """"""Utility function which asserts a schema is valid.

    Throws a TypeError if the schema is invalid.
    """"""
    errors = validate_schema(schema)
    if errors:
        raise TypeError(""\n\n"".join(error.message for error in errors))","def assert_valid_schema(schema): """""" Utility function which asserts a schema is valid. Throws a TypeError if the schema is invalid. """""" if not isinstance(schema): raise TypeError('Schema is invalid') if isinstance(schema): raise TypeError('Schema is invalid') if isinstance(schema): raise TypeError('Schema is invalid')",SFT
0.45161290322580644,0.33333333333333337,0.41935483870967744,0.3254311186362422,0.3254311186362422,0,3.3325817584991455,"def max_word_width(myDict):
    '''
        currd = {0:'AutoPauseSpeed', 125:'HRLimitLow', 6:'Activity'}
        max_wordwidth(currd)
    '''
    maxValueWidth = 0
    for each in myDict:
        eachValueWidth = myDict[each].__len__()
        if(eachValueWidth > maxValueWidth):
            maxValueWidth = eachValueWidth
    return(maxValueWidth)","def max_wordwidth(currd): """""" currd = 0:'AutoPauseSpeed', 125:'HRLimitLow', 6:'Activity' max_wordwidth(currd) """""" if not isinstance(currd, max_wordwidth): raise ValueError(""AutoPauseSpeed 0:'AutoPauseSpeed', 125:'HRLimitLow', 6:'Activity' max_",SFT
0.3129251700680272,0.2876712328767123,0.3061224489795918,0.017490063800918443,0.017490063800918443,0,3.642200469970703,"def _cdf(self, xloc, left, right, cache):
        """"""
        Cumulative distribution function.

        Example:
            >>> print(chaospy.Uniform().fwd([-0.5, 0.5, 1.5, 2.5]))
            [0.  0.5 1.  1. ]
            >>> print(chaospy.Pow(chaospy.Uniform(), 2).fwd([-0.5, 0.5, 1.5, 2.5]))
            [0.         0.70710678 1.         1.        ]
            >>> print(chaospy.Pow(chaospy.Uniform(1, 2), -1).fwd([0.4, 0.6, 0.8, 1.2]))
            [0.         0.33333333 0.75       1.        ]
            >>> print(chaospy.Pow(2, chaospy.Uniform()).fwd([-0.5, 0.5, 1.5, 2.5]))
            [0.        0.        0.5849625 1.       ]
            >>> print(chaospy.Pow(2, chaospy.Uniform(-1, 0)).fwd([0.4, 0.6, 0.8, 1.2]))
            [0.         0.26303441 0.67807191 1.        ]
            >>> print(chaospy.Pow(2, 3).fwd([7, 8, 9]))
            [0. 1. 1.]
        """"""
        left = evaluation.get_forward_cache(left, cache)
        right = evaluation.get_forward_cache(right, cache)

        if isinstance(left, Dist):
            if isinstance(right, Dist):
                raise StochasticallyDependentError(
                    ""under-defined distribution {} or {}"".format(left, right))

        elif not isinstance(right, Dist):
            return numpy.inf

        else:
            assert numpy.all(left > 0), ""imaginary result""

            y = (numpy.log(numpy.abs(xloc) + 1.*(xloc <= 0)) /
                 numpy.log(numpy.abs(left)+1.*(left == 1)))

            out = evaluation.evaluate_forward(right, y)
            out = numpy.where(xloc <= 0, 0., out)
            return out

        y = numpy.sign(xloc)*numpy.abs(xloc)**(1./right)
        pairs = numpy.sign(xloc**right) != -1

        out1, out2 = (
            evaluation.evaluate_forward(left, y, cache=cache),
            evaluation.evaluate_forward(left, -y, cache=cache),
        )
        out = numpy.where(right < 0, 1-out1, out1-pairs*out2)
        return out","def fwd(self): """""" Cumulative distribution function. Example: >>> print(chaospy.Uniform().fwd([-0.5, 0.5, 1.5, 2.5])) [0. 0.5 1. 1. ] >>> print(chaospy.Pow(chaospy.Uniform(), 2).fwd([-0.5, 0.5, 1.5, 2.5])) [0. 0.70710678 1. 1. ] >>> print(chaospy.",SFT
0.4954128440366973,0.35514018691588783,0.4770642201834862,0.21834847382680767,0.21834847382680767,0,2.3144466876983643,"def get_map_offset(self):
        """"""Compute offset of prior/posterior


        Returns
        -------

        map_offest : 1D array
            The offset to different fields in prior/posterior

        """"""

        nfield = 4
        self.map_offset = np.zeros(nfield).astype(int)
        field_size = self.K * np.array([self.n_dim, 1, self.cov_vec_size, 1])
        for i in np.arange(nfield - 1) + 1:
            self.map_offset[i] = self.map_offset[i - 1] + field_size[i - 1]
        return self.map_offset","def compute_offset(self, map_offest): """"""Compute offset of prior/posterior Returns ------- map_offest : 1D array The offset to different fields in prior/posterior """""" if map_offest is None: map_offest = map_offest return map_offest",SFT
0.5714285714285714,0.5086705202312138,0.5714285714285714,0.2019405819357274,0.2019405819357274,0,3.0036795139312744,"def get_converted_image_name(image):
    """"""Return the name of the image after it has been converted to png format.

    Strips off the old extension.

    :param: image (string): The fullpath of the image before conversion

    :return: converted_image (string): the fullpath of the image after convert
    """"""
    png_extension = '.png'

    if image[(0 - len(png_extension)):] == png_extension:
        # it already ends in png!  we're golden
        return image

    img_dir = os.path.split(image)[0]
    image = os.path.split(image)[-1]

    # cut off the old extension
    if len(image.split('.')) > 1:
        old_extension = '.' + image.split('.')[-1]
        converted_image = image[:(0 - len(old_extension))] + png_extension
    else:
        # no extension... damn
        converted_image = image + png_extension

    return os.path.join(img_dir, converted_image)","def convert_image(self, image): """""" Return the name of the image after it has been converted to png format. Strips off the old extension. :param: image (string): The fullpath of the image before conversion :return: converted_image (string): the fullpath of the image after convert """""" if image is None: return self._convert_image(image)",SFT
0.672566371681416,0.6126126126126126,0.672566371681416,0.3180262246927651,0.3180262246927651,1,3.613020420074463,"def updateSpec(self, *args, **kwargs):
        """"""Updates the spectrogram given by kwarg *'plot'*, which is
        either 'response' or (well actually anything). If no arguments 
        are given, clears both spectrograms.

        For other arguments, see: :meth:`SpecWidget.updateData<sparkle.gui.plotting.pyqtgraph_widgets.SpecWidget.updateData>`
        """"""
        if args[0] is None:
            self.stimSpecPlot.clearImg()
            self.responseSpecPlot.clearImg()
        else:
            p = kwargs.pop('plot')
            if p == 'response':
                self.responseSpecPlot.updateData(*args, **kwargs)
            else:
                self.stimSpecPlot.updateData(*args, **kwargs)","def update_spectrogram(self, kwarg): """""" Updates the spectrogram given by kwarg *'plot'*, which is either 'response' or (well actually anything). If no arguments are given, clears both spectrograms. For other arguments, see: :meth:SpecWidget.updateDatasparkle.gui.plotting.pyqtgraph_widgets.SpecWidget.updateData> """"""",SFT
0.8873239436619719,0.8714285714285714,0.8732394366197184,0.7890501975093438,0.7890501975093438,0,3.6271824836730957,"def _get_name(self, name):
        """"""
        Find a team's name and abbreviation.

        Given the team's HTML name tag, determine their name, and abbreviation.

        Parameters
        ----------
        name : PyQuery object
            A PyQuery object of a team's HTML name tag in the boxscore.

        Returns
        -------
        tuple
            Returns a tuple containing the name and abbreviation for a team.
            Tuple is in the following order: Team Name, Team Abbreviation.
        """"""
        team_name = name.text()
        abbr = self._parse_abbreviation(name)
        return team_name, abbr","def find_team_name(self, name): """"""Find a team's name and abbreviation. Given the team's HTML name tag, determine their name, and abbreviation. Parameters ---------- name : PyQuery object A PyQuery object of a team's HTML name tag in the boxscore. Returns ------- tuple Returns a tuple containing the name and abbreviation for a team. Tuple is in the following order: Team Name, Team Ab",SFT
0.6017699115044248,0.4684684684684684,0.5840707964601769,0.4028286588610275,0.4028286588610275,0,3.1385674476623535,"def select_radio_button(self, key):
        """"""Helper to select a radio button with key.

        :param key: The key of the radio button.
        :type key: str
        """"""
        key_index = list(self._parameter.options.keys()).index(key)
        radio_button = self.input_button_group.button(key_index)
        radio_button.click()","def select_radio_button(self, key): """""" Helper to select a radio button with key. :param key: The key of the radio button. :type key: str """""" if key is None: raise ValueError(""Key is not a radio button"") if key is None: raise ValueError(""Key is not a radio button"") if key is None: raise ValueError(""Key is not a radio button"") if key is None: raise ValueError(""",SFT
0.5316455696202531,0.3116883116883117,0.5063291139240508,0.4006937656802107,0.4006937656802107,0,2.507692337036133,"def _pop_entities(self, limit=50):
        """"""
        returns up to limit entities and pops them off the list
        """"""
        pop = self.data['entities'][:limit]
        del self.data['entities'][:limit]
        return pop","def get_limit_entities(self): """""" returns up to limit entities and pops them off the list """""" if self.limit_entities: self.limit_entities = self.limit_entities self.limit_entities = self.limit_entities self.limit_entities = self.limit_entities self.limit_entities = self.limit_entities self.limit_entities = self.limit_entities",SFT
0.24657534246575347,0.1408450704225352,0.21917808219178084,0.15798118033133807,0.15798118033133807,0,3.0842413902282715,"def kvp_dict(d):
    """"""Format dict to key=value pairs.
    """"""
    return ', '.join(
        [""{}={}"".format(k, quotable(v)) for k, v in d.items()])","def _format_dict(self): """"""Format dict to key=value pairs."""""" if not isinstance(self._dict, self._dict, self._dict, self._dict, self._dict, self._dict, self._dict, self._dict, self._dict, self._dict, self._dict, self._dict, self._dict, self._dict, self._dict, self._dict, self._dict, self._dict, self._dict",SFT
0.5258620689655172,0.5043478260869565,0.5086206896551725,0.10750741120316021,0.10750741120316021,0,3.640573263168335,"def determine_inst(i_info, param_str, command):
    """"""Determine the instance-id of the target instance.

    Inspect the number of instance-ids collected and take the
    appropriate action: exit if no ids, return if single id,
    and call user_picklist function if multiple ids exist.

    Args:
        i_info (dict): information and details for instances.
        param_str (str): the title to display in the listing.
        command (str): command specified on the command line.
    Returns:
        tar_inst (str): the AWS instance-id of the target.
    Raises:
        SystemExit: if no instances are match parameters specified.

    """"""
    qty_instances = len(i_info)
    if not qty_instances:
        print(""No instances found with parameters: {}"".format(param_str))
        sys.exit(1)

    if qty_instances > 1:
        print(""{} instances match these parameters:"".format(qty_instances))
        tar_idx = user_picklist(i_info, command)

    else:
        tar_idx = 0
    tar_inst = i_info[tar_idx]['id']
    print(""{0}{3}ing{1} instance id {2}{4}{1}"".
          format(C_STAT[command], C_NORM, C_TI, command, tar_inst))
    return (tar_inst, tar_idx)","def get_instance_id(self, i_info, param_str, command): """"""Determine the instance-id of the target instance. Inspect the number of instance-ids collected and take the appropriate action: exit if no ids, return if single id, and call user_picklist function if multiple ids exist. Args: i_info (dict): information and details for instances. param_str (str): the title to display",SFT
0.3243243243243243,0.2385321100917431,0.3063063063063063,0.2627610845118942,0.2627610845118942,0,3.1261422634124756,"def _create_main_config(cls, overrides=None):
        """"""See comment block at top of 'rezconfig' describing how the main
        config is assembled.""""""
        filepaths = []
        filepaths.append(get_module_root_config())
        filepath = os.getenv(""REZ_CONFIG_FILE"")
        if filepath:
            filepaths.extend(filepath.split(os.pathsep))

        filepath = os.path.expanduser(""~/.rezconfig"")
        filepaths.append(filepath)

        return Config(filepaths, overrides)","def rezconfig(self, rezconfig): """""" See comment block at top of 'rezconfig' describing how the main config is assembled. """""" if rezconfig is None: rezconfig = self.rezconfig if rezconfig is None: rezconfig = self.rezconfig if rezconfig is None: rezconfig = self.rezconfig if rezconfig is None: rezconfig = self.rezconfig if rezconfig is None: rezconfig = self.rezconfig if rezconfig is None",SFT
0.39999999999999997,0.30275229357798167,0.37272727272727274,0.05137269091135303,0.05137269091135303,0,3.3376717567443848,"def chain_present(name, table='filter', table_type=None, hook=None, priority=None, family='ipv4'):
    '''
    .. versionadded:: 2014.7.0

    Verify the chain is exist.

    name
        A user-defined chain name.

    table
        The table to own the chain.

    family
        Networking family, either ipv4 or ipv6
    '''

    ret = {'name': name,
           'changes': {},
           'result': None,
           'comment': ''}

    chain_check = __salt__['nftables.check_chain'](table, name, family=family)
    if chain_check['result'] is True:
        ret['result'] = True
        ret['comment'] = ('nftables {0} chain is already exist in {1} table for {2}'
                          .format(name, table, family))
        return ret

    res = __salt__['nftables.new_chain'](
            table,
            name,
            table_type=table_type,
            hook=hook,
            priority=priority,
            family=family
    )

    if res['result'] is True:
        ret['changes'] = {'locale': name}
        ret['result'] = True
        ret['comment'] = ('nftables {0} chain in {1} table create success for {2}'
                          .format(name, table, family))
        return ret
    else:
        ret['result'] = False
        ret['comment'] = 'Failed to create {0} chain in {1} table: {2} for {3}'.format(
            name,
            table,
            res['comment'].strip(),
            family
        )
        return ret","def verify_chain(self, name, table, family=None): ''' .. versionadded:: 2014.7.0 Verify the chain is exist. name A user-defined chain name. table The table to own the chain. family Networking family, either ipv4 or ipv6 ''' if not isinstance(name, table): raise ValueError('The chain is not ipv4 or ipv6') if not isinstance(name, table): raise ValueEr",SFT
0.7431693989071038,0.7071823204419888,0.7213114754098361,0.6704058003845811,0.6704058003845811,0,3.4592535495758057,"def update(self):
        """"""
        In the case where you have accessed an existing health check on a
        load balancer, this method applies this instance's health check
        values to the load balancer it is attached to.

        .. note:: This method will not do anything if the :py:attr:`access_point`
            attribute isn't set, as is the case with a newly instantiated
            HealthCheck instance.
        """"""
        if not self.access_point:
            return

        new_hc = self.connection.configure_health_check(self.access_point, self)
        self.interval = new_hc.interval
        self.target = new_hc.target
        self.healthy_threshold = new_hc.healthy_threshold
        self.unhealthy_threshold = new_hc.unhealthy_threshold
        self.timeout = new_hc.timeout","def apply_health_check(self, access_point=None): """""" In the case where you have accessed an existing health check on a load balancer, this method applies this instance's health check values to the load balancer it is attached to. .. note:: This method will not do anything if the :py:attr:access_point attribute isn't set, as is the case with a newly instantiated HealthCheck instance. """""" if access_point is None: if access_point",SFT
0.28070175438596495,0.16071428571428573,0.2631578947368421,0.016790749416797597,0.016790749416797597,0,1.905606985092163,"def wait_until_done(self, timeout=None):
        """"""Wait for the background load to complete.""""""
        start = datetime.now()
        if not self.__th:
            raise IndraDBRestResponseError(""There is no thread waiting to ""
                                           ""complete."")
        self.__th.join(timeout)
        now = datetime.now()
        dt = now - start
        if self.__th.is_alive():
            logger.warning(""Timed out after %0.3f seconds waiting for ""
                           ""statement load to complete."" % dt.total_seconds())
            ret = False
        else:
            logger.info(""Waited %0.3f seconds for statements to finish loading.""
                        % dt.total_seconds())
            ret = True
        return ret","def wait_for_background_load(self): """""" Wait for the background load to complete. """""" self._background_load = self._background_load self._background_load = self._background_load self._background_load = self._background_load",SFT
0.25242718446601947,0.17821782178217818,0.25242718446601947,0.1038983861956176,0.1038983861956176,0,2.0310206413269043,"def _serve_forever_wrapper(self, _srv, poll_interval=0.1):
        """"""
        Wrapper for the server created for a SSH forward
        """"""
        self.logger.info('Opening tunnel: {0} <> {1}'.format(
            address_to_str(_srv.local_address),
            address_to_str(_srv.remote_address))
        )
        _srv.serve_forever(poll_interval)  # blocks until finished

        self.logger.info('Tunnel: {0} <> {1} released'.format(
            address_to_str(_srv.local_address),
            address_to_str(_srv.remote_address))
        )","def forward(self): """"""Wrapper for the server created for a SSH forward"""""" if self.ssh_forward is None: self.ssh_forward = self.ssh_forward self.ssh_forward = self.ssh_forward self.ssh_forward = self.ssh_forward",SFT
0.25,0.05128205128205128,0.25,0.1398458360376852,0.1398458360376852,0,2.645672082901001,"def normalize(self, decl_string, arg_separator=None):
        """"""implementation details""""""
        if not self.has_pattern(decl_string):
            return decl_string
        name, args = self.split(decl_string)
        for i, arg in enumerate(args):
            args[i] = self.normalize(arg)
        return self.join(name, args, arg_separator)","def _implement_details(self): """"""implementation details"""""" if self._implement_details is None: self._implement_details = self._implement_details if self._implement_details is None: self._implement_details = self._implement_details self._implement_details = self._implement_details",SFT
0.42857142857142855,0.1774193548387097,0.36507936507936506,0.0911505765511882,0.0911505765511882,0,2.1923441886901855,"async def follow_user(self, request):
        """"""Adds the current user as follower of the given user.""""""
        username = request.match_info['username']
        session = await get_session(request)
        user_id = session.get('user_id')

        if not user_id:
            raise web.HTTPNotAuthorized()

        whom_id = await db.get_user_id(self.mongo.user, username)

        if whom_id is None:
            raise web.HTTPFound()

        await self.mongo.follower.update(
            {'who_id': ObjectId(user_id)},
            {'$push': {'whom_id': whom_id}}, upsert=True)

        return redirect(request, 'user_timeline', parts={""username"": username})","def add_follower(self): """"""Adds the current user as follower of the given user."""""" if self.user is None: self.user.add_follower(self.user) self.user.add_follower(self.user) self.user.add_follower(self.user) self.user.add_follower(self.user)",SFT
0.6283185840707964,0.5982142857142857,0.6194690265486725,0.21375478445652288,0.21375478445652288,0,3.721626043319702,"def parse(self, tokens):
		'''Parses a list of tokens into a JSON-serializable object.

		The parsing proceeds from left to right and is greedy.

		Precedence order:
		  1. Parameters with active context. For example, an Option with
		     nargs=-1 will gobble all the remaining tokens.
		  2. Subcommands.
		  3. Parameters.

		The keys of the returned object are the names of parameters or
		subcommands. Subcommands are encoded as nested objects. Multiple
		parameters are encoded as lists. All other values are encoded as
		parameter-specified data types, or strings if not specified.
		'''
		self._ping_main()

		# Pre-parsing:
		#   1. Expand globbed options: -abc --> -a -b -c
		def is_globbed(s):
			return len(s) > 2 and s.startswith('-') and not s.startswith('--')
		expanded = [[""-"" + c for c in list(token[1:])] if is_globbed(token) else [token] for token in tokens]

		# Parsing: pass off to main command after flattening expanded tokens list
		return self._main.parse(list(itertools.chain.from_iterable(expanded)))","def parse_tokens(self): """"""Parses a list of tokens into a JSON-serializable object. The parsing proceeds from left to right and is greedy. Precedence order: 1. Parameters with active context. For example, an Option with nargs=-1 will gobble all the remaining tokens. 2. Subcommands. 3. Parameters. The keys of the returned object are the names of parameters or subcommands. Subcommands are encoded as nested objects. Multiple parameters are encode",SFT
0.22784810126582278,0.21374045801526723,0.22784810126582278,0.0003956183377802988,0.0003956183377802988,0,3.592717409133911,"def dfa_union(dfa_1: dict, dfa_2: dict) -> dict:
    """""" Returns a DFA accepting the union of the input DFAs.

    Let :math:`A_1 = (, S_1 , s_{01} , _1 , F_1 )` and
    :math:`A_2 = (, S_2 , s_{02} , _2 , F_2 )` be two completed
    DFAs.
    Then there is a DFA :math:`A_` that runs simultaneously both
    :math:`A_1` and :math:`A_2` on the input word
    and accepts when one of them accepts.
    It is defined as:

    :math:`A_ = (, S_1  S_2 , (s_{01} , s_{02} ), , (F_1 
    S_2 )  (S_1  F_2 ))`

    where

    :math:`((s_1 , s_2 ), a) = (s_{X1} , s_{X2} )` iff
    :math:`s_{X1} = _1 (s_1 , a)` and :math:`s_{X2} = (s_2 , a)`

    Proposed implementation guarantees resulting DFA has only **reachable**
    states.

    :param dict dfa_1: first input DFA;
    :param dict dfa_2: second input DFA.
    :return: *(dict)* representing the united DFA.
    """"""
    dfa_1 = deepcopy(dfa_1)
    dfa_2 = deepcopy(dfa_2)
    dfa_1['alphabet'] = dfa_2['alphabet'] = dfa_1['alphabet'].union(
        dfa_2['alphabet'])  # to complete the DFAs over all possible transition
    dfa_1 = dfa_completion(dfa_1)
    dfa_2 = dfa_completion(dfa_2)

    union = {
        'alphabet': dfa_1['alphabet'].copy(),
        'states': {(dfa_1['initial_state'], dfa_2['initial_state'])},
        'initial_state': (dfa_1['initial_state'], dfa_2['initial_state']),
        'accepting_states': set(),
        'transitions': dict()
    }

    boundary = set()
    boundary.add(union['initial_state'])
    while boundary:
        (state_dfa_1, state_dfa_2) = boundary.pop()
        if state_dfa_1 in dfa_1['accepting_states'] \
                or state_dfa_2 in dfa_2['accepting_states']:
            union['accepting_states'].add((state_dfa_1, state_dfa_2))
        for a in union['alphabet']:
            # as DFAs are completed they surely have the transition
            next_state_1 = dfa_1['transitions'][state_dfa_1, a]
            next_state_2 = dfa_2['transitions'][state_dfa_2, a]
            if (next_state_1, next_state_2) not in union['states']:
                union['states'].add((next_state_1, next_state_2))
                boundary.add((next_state_1, next_state_2))
            union['transitions'][(state_dfa_1, state_dfa_2), a] = \
                (next_state_1, next_state_2)

    return union","def union(self): """""" Returns a DFA accepting the union of the input DFAs. Let :math:A_1 = (, S_1 , s_01 , _1 , F_1 ) and :math:A_2 = (, S_2 , s_02 , _2 , F_2 ) be two completed DFAs. Then there is a DFA :math:A_",SFT
